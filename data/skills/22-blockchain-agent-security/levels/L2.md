# L2: Advanced Agent Security Patterns

## Zero-Knowledge Proof Circuits for Agent Credentials

### Circom Circuit: Capability Proof

```circom
pragma circom 2.1.0;

include "circomlib/circuits/poseidon.circom";
include "circomlib/circuits/comparators.circom";

/**
 * AgentCapabilityProof
 * Proves agent has specific capability without revealing credential details
 *
 * Public Inputs:
 * - nullifier: Prevents double-use
 * - capabilityCommitment: Commitment to capability type
 * - minTrustLevel: Required minimum trust level
 *
 * Private Inputs:
 * - agentId: Agent's unique identifier
 * - capabilityType: Type of capability (0-255)
 * - trustLevel: Agent's trust level (0-100)
 * - credentialSecret: Secret known only to credential holder
 * - nullifierSecret: Secret for generating nullifier
 */
template AgentCapabilityProof() {
    // Public inputs
    signal input nullifier;
    signal input capabilityCommitment;
    signal input minTrustLevel;

    // Private inputs
    signal input agentId;
    signal input capabilityType;
    signal input trustLevel;
    signal input credentialSecret;
    signal input nullifierSecret;

    // Output: Proof is valid
    signal output valid;

    // 1. Verify nullifier computation
    component nullifierHash = Poseidon(3);
    nullifierHash.inputs[0] <== agentId;
    nullifierHash.inputs[1] <== capabilityType;
    nullifierHash.inputs[2] <== nullifierSecret;
    nullifierHash.out === nullifier;

    // 2. Verify capability commitment
    component capabilityHash = Poseidon(3);
    capabilityHash.inputs[0] <== agentId;
    capabilityHash.inputs[1] <== capabilityType;
    capabilityHash.inputs[2] <== credentialSecret;
    capabilityHash.out === capabilityCommitment;

    // 3. Verify trust level meets minimum
    component trustCheck = GreaterEqThan(8);  // 8 bits for 0-255
    trustCheck.in[0] <== trustLevel;
    trustCheck.in[1] <== minTrustLevel;
    trustCheck.out === 1;

    // 4. Constrain trust level range (0-100)
    component trustRange = LessThan(8);
    trustRange.in[0] <== trustLevel;
    trustRange.in[1] <== 101;
    trustRange.out === 1;

    valid <== 1;
}

component main {public [nullifier, capabilityCommitment, minTrustLevel]} = AgentCapabilityProof();
```

### Circom Circuit: Reputation Range Proof

```circom
pragma circom 2.1.0;

include "circomlib/circuits/poseidon.circom";
include "circomlib/circuits/comparators.circom";
include "circomlib/circuits/bitify.circom";

/**
 * AgentReputationRangeProof
 * Proves agent's reputation is within a range without revealing exact score
 */
template AgentReputationRangeProof() {
    signal input nullifier;
    signal input agentCommitment;
    signal input minScore;
    signal input maxScore;

    signal input agentId;
    signal input reputationScore;
    signal input stakeAmount;
    signal input secret;

    signal output inRange;

    // Verify commitment
    component commitHash = Poseidon(4);
    commitHash.inputs[0] <== agentId;
    commitHash.inputs[1] <== reputationScore;
    commitHash.inputs[2] <== stakeAmount;
    commitHash.inputs[3] <== secret;
    commitHash.out === agentCommitment;

    // Check score >= minScore
    component minCheck = GreaterEqThan(32);
    minCheck.in[0] <== reputationScore;
    minCheck.in[1] <== minScore;

    // Check score <= maxScore
    component maxCheck = LessEqThan(32);
    maxCheck.in[0] <== reputationScore;
    maxCheck.in[1] <== maxScore;

    // Both conditions must be true
    inRange <== minCheck.out * maxCheck.out;
}

component main {public [nullifier, agentCommitment, minScore, maxScore]} = AgentReputationRangeProof();
```

### Generating and Verifying Proofs

```typescript
import { groth16 } from "snarkjs";
import { buildPoseidon } from "circomlibjs";

interface AgentCredential {
    agentId: bigint;
    capabilityType: number;
    trustLevel: number;
    credentialSecret: bigint;
}

class AgentCredentialProver {
    private poseidon: any;
    private wasmPath: string;
    private zkeyPath: string;

    constructor(wasmPath: string, zkeyPath: string) {
        this.wasmPath = wasmPath;
        this.zkeyPath = zkeyPath;
    }

    async initialize() {
        this.poseidon = await buildPoseidon();
    }

    /**
     * Generate proof of capability
     */
    async proveCapability(
        credential: AgentCredential,
        nullifierSecret: bigint,
        minTrustLevel: number
    ): Promise<{
        proof: any;
        publicSignals: string[];
        nullifier: string;
    }> {
        // Calculate nullifier
        const nullifier = this.poseidon.F.toString(
            this.poseidon([
                credential.agentId,
                credential.capabilityType,
                nullifierSecret
            ])
        );

        // Calculate commitment
        const commitment = this.poseidon.F.toString(
            this.poseidon([
                credential.agentId,
                credential.capabilityType,
                credential.credentialSecret
            ])
        );

        // Prepare inputs
        const input = {
            nullifier: nullifier,
            capabilityCommitment: commitment,
            minTrustLevel: minTrustLevel,
            agentId: credential.agentId.toString(),
            capabilityType: credential.capabilityType,
            trustLevel: credential.trustLevel,
            credentialSecret: credential.credentialSecret.toString(),
            nullifierSecret: nullifierSecret.toString()
        };

        // Generate proof
        const { proof, publicSignals } = await groth16.fullProve(
            input,
            this.wasmPath,
            this.zkeyPath
        );

        return { proof, publicSignals, nullifier };
    }

    /**
     * Verify proof on-chain format
     */
    async formatProofForContract(proof: any): Promise<{
        a: [string, string];
        b: [[string, string], [string, string]];
        c: [string, string];
    }> {
        return {
            a: [proof.pi_a[0], proof.pi_a[1]],
            b: [
                [proof.pi_b[0][1], proof.pi_b[0][0]],
                [proof.pi_b[1][1], proof.pi_b[1][0]]
            ],
            c: [proof.pi_c[0], proof.pi_c[1]]
        };
    }
}

// Usage example
async function demonstrateProof() {
    const prover = new AgentCredentialProver(
        "./build/capability_js/capability.wasm",
        "./build/capability.zkey"
    );
    await prover.initialize();

    const credential: AgentCredential = {
        agentId: BigInt("12345678901234567890"),
        capabilityType: 1,  // TASK_EXECUTION
        trustLevel: 85,
        credentialSecret: BigInt("98765432109876543210")
    };

    const { proof, publicSignals, nullifier } = await prover.proveCapability(
        credential,
        BigInt("11111111111111111111"),  // nullifier secret
        50  // minimum trust level required
    );

    console.log("Proof generated:", proof);
    console.log("Public signals:", publicSignals);
    console.log("Nullifier:", nullifier);
}
```

## Cross-Chain Agent Identity

### LayerZero Integration

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title CrossChainAgentIdentity
 * @notice Synchronize agent identity and reputation across chains
 */
contract CrossChainAgentIdentity is OApp {

    struct CrossChainAgent {
        bytes32 agentId;
        uint256 reputationScore;
        uint256 lastSyncTime;
        bool isRegistered;
    }

    mapping(bytes32 => CrossChainAgent) public agents;

    // Message types
    uint8 constant MSG_REGISTER = 1;
    uint8 constant MSG_UPDATE_REPUTATION = 2;
    uint8 constant MSG_REVOKE = 3;

    event AgentSynced(bytes32 indexed agentId, uint32 srcChainId, uint256 reputation);
    event ReputationSyncRequested(bytes32 indexed agentId, uint32 dstChainId);

    constructor(address _endpoint, address _owner) OApp(_endpoint, _owner) Ownable(_owner) {}

    /**
     * @notice Register agent identity across chains
     */
    function registerCrossChain(
        bytes32 agentId,
        uint256 initialReputation,
        uint32[] calldata dstChainIds
    ) external payable {
        require(!agents[agentId].isRegistered, "Already registered");

        agents[agentId] = CrossChainAgent({
            agentId: agentId,
            reputationScore: initialReputation,
            lastSyncTime: block.timestamp,
            isRegistered: true
        });

        // Broadcast to other chains
        bytes memory payload = abi.encode(MSG_REGISTER, agentId, initialReputation);

        for (uint256 i = 0; i < dstChainIds.length; i++) {
            _lzSend(
                dstChainIds[i],
                payload,
                _buildOptions(200000),  // gas limit
                MessagingFee(msg.value / dstChainIds.length, 0),
                payable(msg.sender)
            );
        }
    }

    /**
     * @notice Sync reputation update to other chains
     */
    function syncReputation(
        bytes32 agentId,
        int256 reputationDelta,
        uint32[] calldata dstChainIds
    ) external payable {
        require(agents[agentId].isRegistered, "Agent not registered");

        // Update local state
        if (reputationDelta > 0) {
            agents[agentId].reputationScore += uint256(reputationDelta);
        } else {
            uint256 decrease = uint256(-reputationDelta);
            if (decrease > agents[agentId].reputationScore) {
                agents[agentId].reputationScore = 0;
            } else {
                agents[agentId].reputationScore -= decrease;
            }
        }
        agents[agentId].lastSyncTime = block.timestamp;

        // Broadcast update
        bytes memory payload = abi.encode(
            MSG_UPDATE_REPUTATION,
            agentId,
            agents[agentId].reputationScore
        );

        for (uint256 i = 0; i < dstChainIds.length; i++) {
            _lzSend(
                dstChainIds[i],
                payload,
                _buildOptions(150000),
                MessagingFee(msg.value / dstChainIds.length, 0),
                payable(msg.sender)
            );

            emit ReputationSyncRequested(agentId, dstChainIds[i]);
        }
    }

    /**
     * @notice Receive cross-chain message
     */
    function _lzReceive(
        Origin calldata _origin,
        bytes32 /*_guid*/,
        bytes calldata payload,
        address /*_executor*/,
        bytes calldata /*_extraData*/
    ) internal override {
        (uint8 msgType, bytes32 agentId, uint256 reputation) = abi.decode(
            payload,
            (uint8, bytes32, uint256)
        );

        if (msgType == MSG_REGISTER) {
            if (!agents[agentId].isRegistered) {
                agents[agentId] = CrossChainAgent({
                    agentId: agentId,
                    reputationScore: reputation,
                    lastSyncTime: block.timestamp,
                    isRegistered: true
                });
            }
        } else if (msgType == MSG_UPDATE_REPUTATION) {
            if (agents[agentId].isRegistered) {
                agents[agentId].reputationScore = reputation;
                agents[agentId].lastSyncTime = block.timestamp;
            }
        } else if (msgType == MSG_REVOKE) {
            agents[agentId].isRegistered = false;
        }

        emit AgentSynced(agentId, _origin.srcEid, reputation);
    }

    function _buildOptions(uint128 gasLimit) internal pure returns (bytes memory) {
        return abi.encodePacked(uint16(1), gasLimit);
    }
}
```

## Advanced Security Patterns

### Time-Locked Multi-Sig for Agent Upgrades

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title AgentUpgradeTimelock
 * @notice Time-locked multi-sig for critical agent system upgrades
 */
contract AgentUpgradeTimelock {

    uint256 public constant MIN_DELAY = 2 days;
    uint256 public constant MAX_DELAY = 30 days;
    uint256 public constant GRACE_PERIOD = 14 days;

    address[] public guardians;
    uint256 public requiredApprovals;

    struct Proposal {
        bytes32 id;
        address target;
        uint256 value;
        bytes data;
        uint256 eta;  // Execution time
        bool executed;
        uint256 approvalCount;
        mapping(address => bool) hasApproved;
    }

    mapping(bytes32 => Proposal) public proposals;
    mapping(address => bool) public isGuardian;

    event ProposalCreated(bytes32 indexed id, address target, uint256 eta);
    event ProposalApproved(bytes32 indexed id, address guardian);
    event ProposalExecuted(bytes32 indexed id);
    event ProposalCancelled(bytes32 indexed id);

    modifier onlyGuardian() {
        require(isGuardian[msg.sender], "Not guardian");
        _;
    }

    constructor(address[] memory _guardians, uint256 _requiredApprovals) {
        require(_guardians.length >= _requiredApprovals, "Invalid config");
        require(_requiredApprovals >= 2, "Need at least 2 approvals");

        for (uint256 i = 0; i < _guardians.length; i++) {
            isGuardian[_guardians[i]] = true;
        }
        guardians = _guardians;
        requiredApprovals = _requiredApprovals;
    }

    /**
     * @notice Create upgrade proposal
     */
    function propose(
        address target,
        uint256 value,
        bytes calldata data,
        uint256 delay
    ) external onlyGuardian returns (bytes32) {
        require(delay >= MIN_DELAY && delay <= MAX_DELAY, "Invalid delay");

        bytes32 id = keccak256(abi.encode(
            target, value, data, block.timestamp
        ));

        Proposal storage proposal = proposals[id];
        require(proposal.eta == 0, "Proposal exists");

        proposal.id = id;
        proposal.target = target;
        proposal.value = value;
        proposal.data = data;
        proposal.eta = block.timestamp + delay;
        proposal.approvalCount = 1;
        proposal.hasApproved[msg.sender] = true;

        emit ProposalCreated(id, target, proposal.eta);
        emit ProposalApproved(id, msg.sender);

        return id;
    }

    /**
     * @notice Approve proposal
     */
    function approve(bytes32 id) external onlyGuardian {
        Proposal storage proposal = proposals[id];
        require(proposal.eta > 0, "Proposal not found");
        require(!proposal.executed, "Already executed");
        require(!proposal.hasApproved[msg.sender], "Already approved");
        require(block.timestamp < proposal.eta + GRACE_PERIOD, "Expired");

        proposal.hasApproved[msg.sender] = true;
        proposal.approvalCount++;

        emit ProposalApproved(id, msg.sender);
    }

    /**
     * @notice Execute approved proposal
     */
    function execute(bytes32 id) external onlyGuardian {
        Proposal storage proposal = proposals[id];
        require(proposal.eta > 0, "Proposal not found");
        require(!proposal.executed, "Already executed");
        require(proposal.approvalCount >= requiredApprovals, "Not enough approvals");
        require(block.timestamp >= proposal.eta, "Timelock not passed");
        require(block.timestamp < proposal.eta + GRACE_PERIOD, "Expired");

        proposal.executed = true;

        (bool success, ) = proposal.target.call{value: proposal.value}(proposal.data);
        require(success, "Execution failed");

        emit ProposalExecuted(id);
    }

    /**
     * @notice Cancel proposal (requires majority)
     */
    function cancel(bytes32 id) external onlyGuardian {
        Proposal storage proposal = proposals[id];
        require(proposal.eta > 0, "Proposal not found");
        require(!proposal.executed, "Already executed");

        // Reset proposal
        delete proposals[id];

        emit ProposalCancelled(id);
    }
}
```

### Circuit Breaker Pattern

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title AgentCircuitBreaker
 * @notice Emergency circuit breaker for agent systems
 */
abstract contract AgentCircuitBreaker {

    enum CircuitState { CLOSED, OPEN, HALF_OPEN }

    struct Circuit {
        CircuitState state;
        uint256 failureCount;
        uint256 lastFailureTime;
        uint256 successCount;
    }

    uint256 public constant FAILURE_THRESHOLD = 5;
    uint256 public constant RECOVERY_TIMEOUT = 1 hours;
    uint256 public constant HALF_OPEN_SUCCESS_THRESHOLD = 3;

    mapping(bytes32 => Circuit) public circuits;

    event CircuitOpened(bytes32 indexed circuitId);
    event CircuitClosed(bytes32 indexed circuitId);
    event CircuitHalfOpen(bytes32 indexed circuitId);

    modifier withCircuitBreaker(bytes32 circuitId) {
        Circuit storage circuit = circuits[circuitId];

        // Check if circuit is open
        if (circuit.state == CircuitState.OPEN) {
            // Check if recovery timeout has passed
            if (block.timestamp >= circuit.lastFailureTime + RECOVERY_TIMEOUT) {
                circuit.state = CircuitState.HALF_OPEN;
                circuit.successCount = 0;
                emit CircuitHalfOpen(circuitId);
            } else {
                revert("Circuit is open");
            }
        }

        _;
    }

    /**
     * @notice Record successful operation
     */
    function _recordSuccess(bytes32 circuitId) internal {
        Circuit storage circuit = circuits[circuitId];

        if (circuit.state == CircuitState.HALF_OPEN) {
            circuit.successCount++;
            if (circuit.successCount >= HALF_OPEN_SUCCESS_THRESHOLD) {
                circuit.state = CircuitState.CLOSED;
                circuit.failureCount = 0;
                emit CircuitClosed(circuitId);
            }
        } else if (circuit.state == CircuitState.CLOSED) {
            // Reset failure count on success
            circuit.failureCount = 0;
        }
    }

    /**
     * @notice Record failed operation
     */
    function _recordFailure(bytes32 circuitId) internal {
        Circuit storage circuit = circuits[circuitId];

        circuit.failureCount++;
        circuit.lastFailureTime = block.timestamp;

        if (circuit.state == CircuitState.HALF_OPEN) {
            // Immediately open on failure during half-open
            circuit.state = CircuitState.OPEN;
            emit CircuitOpened(circuitId);
        } else if (circuit.failureCount >= FAILURE_THRESHOLD) {
            circuit.state = CircuitState.OPEN;
            emit CircuitOpened(circuitId);
        }
    }

    /**
     * @notice Manual circuit reset (admin only)
     */
    function _resetCircuit(bytes32 circuitId) internal {
        Circuit storage circuit = circuits[circuitId];
        circuit.state = CircuitState.CLOSED;
        circuit.failureCount = 0;
        circuit.successCount = 0;
        emit CircuitClosed(circuitId);
    }
}
```

## Audit Workflow

### Pre-Audit Checklist

```yaml
Code Quality:
  - [ ] All tests passing with >95% coverage
  - [ ] No compiler warnings
  - [ ] NatSpec documentation complete
  - [ ] Gas optimization verified

Static Analysis:
  - [ ] Slither: No high/medium findings
  - [ ] Mythril: No critical vulnerabilities
  - [ ] Solhint: Style guide compliance

Access Control:
  - [ ] All admin functions protected
  - [ ] Role hierarchy documented
  - [ ] Emergency functions tested
  - [ ] Upgrade paths secure

Agent-Specific:
  - [ ] Identity verification tested
  - [ ] Reputation calculation audited
  - [ ] ZK circuits formally verified
  - [ ] Cross-chain sync validated
```

### Formal Verification Specs (Certora)

```cvl
// AgentIdentityRegistry.spec

methods {
    function registerAgent(bytes32, bytes32, address[]) external;
    function rotateKey(bytes32, address, bytes) external;
    function getAgent(bytes32) external returns (address, address, uint256, uint256, bool, uint8);
}

// Invariant: Registered agent always has non-zero owner
invariant agentHasOwner(bytes32 agentId)
    agents[agentId].isActive => agents[agentId].owner != 0

// Rule: Only owner can rotate keys
rule onlyOwnerCanRotateKey(bytes32 agentId, address newKey, bytes sig) {
    address ownerBefore = agents[agentId].owner;

    rotateKey(agentId, newKey, sig);

    assert agents[agentId].owner == ownerBefore;
}

// Rule: Deactivated agent cannot perform actions
rule deactivatedAgentBlocked(bytes32 agentId, bytes32 msgHash, bytes sig) {
    require !agents[agentId].isActive;

    bool result = verifyAgentSignature(agentId, msgHash, sig);

    assert !result;
}

// Rule: Trust tier only increases through authorized updates
rule trustTierOnlyIncreasesByOperator(bytes32 agentId, uint8 newTier) {
    uint8 tierBefore = agents[agentId].trustTier;

    updateTrustTier(agentId, newTier);

    assert newTier >= tierBefore || msg.sender == OPERATOR;
}
```

## Integration with Multi-Agent Systems

### Agent Pool Integration

```typescript
import { ethers } from "ethers";
import { AgentIdentityRegistry__factory } from "./typechain";
import { AgentReputationSystem__factory } from "./typechain";

interface BlockchainAgentConfig {
    identityRegistryAddress: string;
    reputationSystemAddress: string;
    provider: ethers.Provider;
    signer: ethers.Signer;
}

class BlockchainAgentManager {
    private identityRegistry: AgentIdentityRegistry;
    private reputationSystem: AgentReputationSystem;

    constructor(config: BlockchainAgentConfig) {
        this.identityRegistry = AgentIdentityRegistry__factory.connect(
            config.identityRegistryAddress,
            config.signer
        );
        this.reputationSystem = AgentReputationSystem__factory.connect(
            config.reputationSystemAddress,
            config.signer
        );
    }

    /**
     * Register agent in multi-agent pool with blockchain identity
     */
    async registerPoolAgent(
        agentId: string,
        metadata: {
            name: string;
            capabilities: string[];
            tier: number;
        },
        recoveryAddresses: string[]
    ): Promise<{
        txHash: string;
        agentIdBytes32: string;
    }> {
        const agentIdBytes32 = ethers.id(agentId);
        const metadataHash = ethers.id(JSON.stringify(metadata));

        const tx = await this.identityRegistry.registerAgent(
            agentIdBytes32,
            metadataHash,
            recoveryAddresses
        );

        const receipt = await tx.wait();

        return {
            txHash: receipt!.hash,
            agentIdBytes32
        };
    }

    /**
     * Verify agent before task assignment
     */
    async verifyAgentForTask(
        agentIdBytes32: string,
        requiredScore: bigint,
        requiredStake: bigint
    ): Promise<{
        isEligible: boolean;
        currentScore: bigint;
        currentStake: bigint;
    }> {
        const [
            totalScore,
            stakedAmount,
            successfulTasks,
            failedTasks,
            successRate
        ] = await this.reputationSystem.getReputation(agentIdBytes32);

        const meetsThreshold = await this.reputationSystem.meetsThreshold(
            agentIdBytes32,
            requiredScore,
            requiredStake
        );

        return {
            isEligible: meetsThreshold,
            currentScore: totalScore,
            currentStake: stakedAmount
        };
    }

    /**
     * Record task outcome and update reputation
     */
    async recordTaskOutcome(
        agentIdBytes32: string,
        success: boolean,
        category: number,
        details: string
    ): Promise<string> {
        let tx;

        if (success) {
            tx = await this.reputationSystem.addReputation(
                agentIdBytes32,
                category,
                ethers.parseEther("10"),  // 10 points
                details
            );
        } else {
            tx = await this.reputationSystem.slash(
                agentIdBytes32,
                category,
                3,  // severity 1-10
                details
            );
        }

        const receipt = await tx.wait();
        return receipt!.hash;
    }
}
```

## Gas Optimization

### Storage Packing

```solidity
// Before: 3 storage slots
struct AgentBad {
    address owner;        // slot 0
    uint256 createdAt;    // slot 1
    uint256 lastActivity; // slot 2
    bool isActive;        // slot 3
    uint8 trustTier;      // slot 3
}

// After: 2 storage slots
struct AgentOptimized {
    address owner;        // slot 0 (20 bytes)
    uint48 createdAt;     // slot 0 (6 bytes) - fits timestamp until year 8.9M
    uint48 lastActivity;  // slot 1 (6 bytes)
    bool isActive;        // slot 1 (1 byte)
    uint8 trustTier;      // slot 1 (1 byte)
    // slot 1 has 24 bytes free for future use
}

// Gas savings: ~20,000 gas per write
```

### Batch Operations

```solidity
/**
 * @notice Batch update reputation for multiple agents
 * @dev Saves gas by batching storage writes
 */
function batchUpdateReputation(
    bytes32[] calldata agentIds,
    uint256[] calldata scores,
    ReputationCategory[] calldata categories
) external onlyRole(SCORER_ROLE) {
    require(
        agentIds.length == scores.length &&
        scores.length == categories.length,
        "Length mismatch"
    );

    for (uint256 i = 0; i < agentIds.length; i++) {
        // Use unchecked for gas savings (we validate lengths above)
        unchecked {
            ReputationScore storage rep = reputations[agentIds[i]];
            rep.categoryScores[categories[i]] += scores[i];
            rep.totalScore += scores[i];
            rep.lastUpdateTime = block.timestamp;
        }

        emit ReputationUpdated(
            agentIds[i],
            categories[i],
            int256(scores[i]),
            reputations[agentIds[i]].totalScore
        );
    }
}
```

## Testing Strategies

### Invariant Testing (Foundry)

```solidity
// test/invariants/ReputationInvariants.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../../src/AgentReputationSystem.sol";

contract ReputationInvariantTest is Test {
    AgentReputationSystem public reputation;
    Handler public handler;

    function setUp() public {
        reputation = new AgentReputationSystem();
        handler = new Handler(reputation);

        targetContract(address(handler));
    }

    /// @dev Total score should never exceed MAX_SCORE
    function invariant_scoreNeverExceedsMax() public {
        bytes32[] memory agents = handler.getRegisteredAgents();

        for (uint256 i = 0; i < agents.length; i++) {
            (uint256 score, , , , ) = reputation.getReputation(agents[i]);
            assertLe(score, reputation.MAX_SCORE());
        }
    }

    /// @dev Slashing should never increase score
    function invariant_slashingNeverIncreasesScore() public {
        // Tracked in handler
        assertTrue(handler.slashingNeverIncreased());
    }

    /// @dev Staked amount should match contract balance
    function invariant_stakedMatchesBalance() public {
        assertEq(
            handler.totalStaked(),
            address(reputation).balance
        );
    }
}

contract Handler is Test {
    AgentReputationSystem public reputation;
    bytes32[] public registeredAgents;
    uint256 public totalStaked;

    mapping(bytes32 => uint256) public scoreBeforeSlash;
    bool public slashingNeverIncreased = true;

    constructor(AgentReputationSystem _reputation) {
        reputation = _reputation;
    }

    function stake(bytes32 agentId, uint256 amount) public {
        amount = bound(amount, 0.1 ether, 10 ether);
        deal(address(this), amount);

        reputation.stake{value: amount}(agentId);

        if (!_isRegistered(agentId)) {
            registeredAgents.push(agentId);
        }
        totalStaked += amount;
    }

    function slash(bytes32 agentId, uint8 severity) public {
        if (!_isRegistered(agentId)) return;

        severity = uint8(bound(severity, 1, 10));

        (uint256 scoreBefore, , , , ) = reputation.getReputation(agentId);
        scoreBeforeSlash[agentId] = scoreBefore;

        reputation.slash(
            agentId,
            AgentReputationSystem.ReputationCategory.TASK_COMPLETION,
            severity,
            "Test slash"
        );

        (uint256 scoreAfter, , , , ) = reputation.getReputation(agentId);

        if (scoreAfter > scoreBefore) {
            slashingNeverIncreased = false;
        }
    }

    function getRegisteredAgents() external view returns (bytes32[] memory) {
        return registeredAgents;
    }

    function _isRegistered(bytes32 agentId) internal view returns (bool) {
        for (uint256 i = 0; i < registeredAgents.length; i++) {
            if (registeredAgents[i] == agentId) return true;
        }
        return false;
    }
}
```

â†’ Load L3 for production deployment scripts, mainnet security hardening, and incident response procedures
