# L3: Production Deployment & Incident Response

> Enterprise-grade deployment, mainnet security hardening, and incident response for AI agent blockchain infrastructure.

## Deployment Architecture

### Multi-Chain Deployment Strategy

```typescript
// deploy/MultiChainDeployer.ts
import { ethers } from "hardhat";
import { LayerZeroEndpoint } from "@layerzerolabs/lz-evm-sdk-v2";

interface ChainConfig {
  chainId: number;
  rpcUrl: string;
  lzEndpoint: string;
  gasPrice: bigint;
  confirmations: number;
  timelock: number;
}

const CHAIN_CONFIGS: Record<string, ChainConfig> = {
  ethereum: {
    chainId: 1,
    rpcUrl: process.env.ETH_RPC_URL!,
    lzEndpoint: "0x1a44076050125825900e736c501f859c50fE728c",
    gasPrice: 30_000_000_000n,
    confirmations: 3,
    timelock: 48 * 60 * 60, // 48 hours
  },
  arbitrum: {
    chainId: 42161,
    rpcUrl: process.env.ARB_RPC_URL!,
    lzEndpoint: "0x3c2269811836af69497E5F486A85D7316753cf62",
    gasPrice: 100_000_000n,
    confirmations: 1,
    timelock: 24 * 60 * 60, // 24 hours
  },
  base: {
    chainId: 8453,
    rpcUrl: process.env.BASE_RPC_URL!,
    lzEndpoint: "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
    gasPrice: 1_000_000n,
    confirmations: 1,
    timelock: 24 * 60 * 60,
  },
};

export class MultiChainDeployer {
  private deployedContracts: Map<string, Map<string, string>> = new Map();

  async deployAll(targetChains: string[]): Promise<DeploymentReport> {
    const report: DeploymentReport = {
      timestamp: Date.now(),
      chains: {},
      crossChainLinks: [],
    };

    // Phase 1: Deploy core contracts on each chain
    for (const chain of targetChains) {
      console.log(`\nðŸš€ Deploying to ${chain}...`);
      const contracts = await this.deployToChain(chain);
      report.chains[chain] = contracts;
      this.deployedContracts.set(chain, new Map(Object.entries(contracts)));
    }

    // Phase 2: Link cross-chain communication
    for (const sourceChain of targetChains) {
      for (const destChain of targetChains) {
        if (sourceChain !== destChain) {
          await this.linkChains(sourceChain, destChain);
          report.crossChainLinks.push({ source: sourceChain, dest: destChain });
        }
      }
    }

    // Phase 3: Verify all contracts
    for (const chain of targetChains) {
      await this.verifyContracts(chain);
    }

    return report;
  }

  private async deployToChain(chain: string): Promise<Record<string, string>> {
    const config = CHAIN_CONFIGS[chain];
    const provider = new ethers.JsonRpcProvider(config.rpcUrl);
    const deployer = new ethers.Wallet(process.env.DEPLOYER_KEY!, provider);

    // Deploy with deterministic addresses using CREATE2
    const create2Factory = await ethers.getContractAt(
      "Create2Factory",
      "0x4e59b44847b379578588920cA78FbF26c0B4956C"
    );

    // 1. Deploy Timelock first
    const Timelock = await ethers.getContractFactory("TimelockController");
    const timelockSalt = ethers.keccak256(ethers.toUtf8Bytes(`timelock-${chain}-v1`));
    const timelockAddress = await this.deployCreate2(
      create2Factory,
      Timelock,
      [config.timelock, [], [], deployer.address],
      timelockSalt
    );

    // 2. Deploy Identity Registry
    const IdentityRegistry = await ethers.getContractFactory("AgentIdentityRegistry");
    const identitySalt = ethers.keccak256(ethers.toUtf8Bytes(`identity-${chain}-v1`));
    const identityAddress = await this.deployCreate2(
      create2Factory,
      IdentityRegistry,
      [],
      identitySalt
    );

    // 3. Deploy Reputation System
    const ReputationSystem = await ethers.getContractFactory("AgentReputationSystem");
    const reputationSalt = ethers.keccak256(ethers.toUtf8Bytes(`reputation-${chain}-v1`));
    const reputationAddress = await this.deployCreate2(
      create2Factory,
      ReputationSystem,
      [identityAddress],
      reputationSalt
    );

    // 4. Deploy Credential Verifier with ZK verifiers
    const CredentialVerifier = await ethers.getContractFactory("AgentCredentialVerifier");
    const verifierSalt = ethers.keccak256(ethers.toUtf8Bytes(`verifier-${chain}-v1`));
    const verifierAddress = await this.deployCreate2(
      create2Factory,
      CredentialVerifier,
      [identityAddress],
      verifierSalt
    );

    // 5. Deploy Cross-Chain Bridge
    const CrossChainBridge = await ethers.getContractFactory("CrossChainAgentBridge");
    const bridgeSalt = ethers.keccak256(ethers.toUtf8Bytes(`bridge-${chain}-v1`));
    const bridgeAddress = await this.deployCreate2(
      create2Factory,
      CrossChainBridge,
      [config.lzEndpoint, identityAddress, reputationAddress],
      bridgeSalt
    );

    // Transfer ownership to timelock
    const identity = await ethers.getContractAt("AgentIdentityRegistry", identityAddress);
    const reputation = await ethers.getContractAt("AgentReputationSystem", reputationAddress);

    await identity.grantRole(await identity.DEFAULT_ADMIN_ROLE(), timelockAddress);
    await reputation.grantRole(await reputation.DEFAULT_ADMIN_ROLE(), timelockAddress);

    console.log(`âœ… ${chain} deployment complete`);

    return {
      timelock: timelockAddress,
      identityRegistry: identityAddress,
      reputationSystem: reputationAddress,
      credentialVerifier: verifierAddress,
      crossChainBridge: bridgeAddress,
    };
  }

  private async deployCreate2(
    factory: ethers.Contract,
    contractFactory: ethers.ContractFactory,
    args: any[],
    salt: string
  ): Promise<string> {
    const bytecode = contractFactory.bytecode;
    const initCode = contractFactory.interface.encodeDeploy(args);
    const fullBytecode = ethers.concat([bytecode, initCode]);

    const computedAddress = ethers.getCreate2Address(
      await factory.getAddress(),
      salt,
      ethers.keccak256(fullBytecode)
    );

    // Check if already deployed
    const code = await factory.runner!.provider!.getCode(computedAddress);
    if (code !== "0x") {
      console.log(`  Contract already deployed at ${computedAddress}`);
      return computedAddress;
    }

    const tx = await factory.deploy(salt, fullBytecode);
    await tx.wait();

    console.log(`  Deployed at ${computedAddress}`);
    return computedAddress;
  }

  private async linkChains(sourceChain: string, destChain: string): Promise<void> {
    const sourceContracts = this.deployedContracts.get(sourceChain)!;
    const destContracts = this.deployedContracts.get(destChain)!;

    const sourceConfig = CHAIN_CONFIGS[sourceChain];
    const destConfig = CHAIN_CONFIGS[destChain];

    const provider = new ethers.JsonRpcProvider(sourceConfig.rpcUrl);
    const signer = new ethers.Wallet(process.env.DEPLOYER_KEY!, provider);

    const bridge = await ethers.getContractAt(
      "CrossChainAgentBridge",
      sourceContracts.get("crossChainBridge")!,
      signer
    );

    // Set trusted remote
    await bridge.setTrustedRemote(
      destConfig.chainId,
      ethers.solidityPacked(
        ["address", "address"],
        [destContracts.get("crossChainBridge")!, sourceContracts.get("crossChainBridge")!]
      )
    );

    console.log(`  Linked ${sourceChain} â†’ ${destChain}`);
  }

  private async verifyContracts(chain: string): Promise<void> {
    // Verification logic for block explorers
    console.log(`ðŸ“‹ Verify contracts on ${chain} block explorer...`);
  }
}

interface DeploymentReport {
  timestamp: number;
  chains: Record<string, Record<string, string>>;
  crossChainLinks: { source: string; dest: string }[];
}
```

### Security Hardening Checklist

```solidity
// contracts/security/SecurityConfig.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/// @title Security configuration for production deployment
/// @notice Implements defense-in-depth security measures
contract SecurityConfig is AccessControl, Pausable {
    bytes32 public constant SECURITY_ADMIN = keccak256("SECURITY_ADMIN");
    bytes32 public constant EMERGENCY_ADMIN = keccak256("EMERGENCY_ADMIN");

    // Rate limiting
    struct RateLimitConfig {
        uint256 maxOperationsPerBlock;
        uint256 maxOperationsPerHour;
        uint256 cooldownPeriod;
    }

    mapping(bytes4 => RateLimitConfig) public rateLimits;
    mapping(address => mapping(bytes4 => uint256)) public operationCounts;
    mapping(address => mapping(bytes4 => uint256)) public lastOperationBlock;

    // Value limits
    uint256 public maxStakeAmount = 100 ether;
    uint256 public maxReputationChange = 1000;
    uint256 public maxSlashPercentage = 50; // Max 50% slash

    // Emergency controls
    bool public emergencyMode;
    uint256 public emergencyActivatedAt;
    uint256 public constant EMERGENCY_DURATION = 24 hours;

    // Blacklist for compromised agents
    mapping(bytes32 => bool) public blacklistedAgents;
    mapping(address => bool) public blacklistedAddresses;

    event EmergencyActivated(address indexed activator, string reason);
    event EmergencyDeactivated(address indexed deactivator);
    event AgentBlacklisted(bytes32 indexed agentId, string reason);
    event AddressBlacklisted(address indexed addr, string reason);
    event RateLimitUpdated(bytes4 indexed selector, uint256 maxPerBlock, uint256 maxPerHour);

    modifier notBlacklisted(address addr) {
        require(!blacklistedAddresses[addr], "Address blacklisted");
        _;
    }

    modifier agentNotBlacklisted(bytes32 agentId) {
        require(!blacklistedAgents[agentId], "Agent blacklisted");
        _;
    }

    modifier rateLimited(bytes4 selector) {
        RateLimitConfig memory config = rateLimits[selector];
        if (config.maxOperationsPerBlock > 0) {
            if (lastOperationBlock[msg.sender][selector] == block.number) {
                require(
                    operationCounts[msg.sender][selector] < config.maxOperationsPerBlock,
                    "Rate limit exceeded: per block"
                );
            } else {
                operationCounts[msg.sender][selector] = 0;
                lastOperationBlock[msg.sender][selector] = block.number;
            }
            operationCounts[msg.sender][selector]++;
        }
        _;
    }

    modifier notInEmergency() {
        require(!emergencyMode || block.timestamp > emergencyActivatedAt + EMERGENCY_DURATION,
            "Emergency mode active");
        _;
    }

    function activateEmergency(string calldata reason) external onlyRole(EMERGENCY_ADMIN) {
        emergencyMode = true;
        emergencyActivatedAt = block.timestamp;
        _pause();
        emit EmergencyActivated(msg.sender, reason);
    }

    function deactivateEmergency() external onlyRole(SECURITY_ADMIN) {
        require(emergencyMode, "Not in emergency");
        require(
            block.timestamp > emergencyActivatedAt + EMERGENCY_DURATION ||
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Emergency duration not elapsed"
        );
        emergencyMode = false;
        _unpause();
        emit EmergencyDeactivated(msg.sender);
    }

    function blacklistAgent(bytes32 agentId, string calldata reason)
        external
        onlyRole(SECURITY_ADMIN)
    {
        blacklistedAgents[agentId] = true;
        emit AgentBlacklisted(agentId, reason);
    }

    function blacklistAddress(address addr, string calldata reason)
        external
        onlyRole(SECURITY_ADMIN)
    {
        blacklistedAddresses[addr] = true;
        emit AddressBlacklisted(addr, reason);
    }

    function setRateLimit(
        bytes4 selector,
        uint256 maxPerBlock,
        uint256 maxPerHour,
        uint256 cooldown
    ) external onlyRole(SECURITY_ADMIN) {
        rateLimits[selector] = RateLimitConfig({
            maxOperationsPerBlock: maxPerBlock,
            maxOperationsPerHour: maxPerHour,
            cooldownPeriod: cooldown
        });
        emit RateLimitUpdated(selector, maxPerBlock, maxPerHour);
    }

    function setValueLimits(
        uint256 _maxStake,
        uint256 _maxRepChange,
        uint256 _maxSlash
    ) external onlyRole(SECURITY_ADMIN) {
        require(_maxSlash <= 100, "Slash cannot exceed 100%");
        maxStakeAmount = _maxStake;
        maxReputationChange = _maxRepChange;
        maxSlashPercentage = _maxSlash;
    }
}
```

## Monitoring & Alerting

### Real-Time Event Monitoring

```typescript
// monitoring/EventMonitor.ts
import { ethers } from "ethers";
import { WebSocket } from "ws";

interface AlertConfig {
  webhookUrl: string;
  slackChannel?: string;
  pagerDutyKey?: string;
  telegramBotToken?: string;
  telegramChatId?: string;
}

interface MonitoringRule {
  name: string;
  contract: string;
  event: string;
  condition: (log: ethers.Log, decoded: any) => boolean;
  severity: "info" | "warning" | "critical";
  message: (decoded: any) => string;
}

export class BlockchainMonitor {
  private providers: Map<string, ethers.Provider> = new Map();
  private contracts: Map<string, ethers.Contract> = new Map();
  private rules: MonitoringRule[] = [];
  private alertConfig: AlertConfig;

  constructor(alertConfig: AlertConfig) {
    this.alertConfig = alertConfig;
    this.initializeRules();
  }

  private initializeRules(): void {
    this.rules = [
      // Identity Registry alerts
      {
        name: "Agent Registration Spike",
        contract: "AgentIdentityRegistry",
        event: "AgentRegistered",
        condition: (log, decoded) => {
          // Alert if more than 100 registrations in same block
          return this.getEventCountInBlock(log.blockNumber, "AgentRegistered") > 100;
        },
        severity: "warning",
        message: (decoded) => `High registration activity: Agent ${decoded.agentId}`,
      },
      {
        name: "Key Rotation Alert",
        contract: "AgentIdentityRegistry",
        event: "KeyRotated",
        condition: () => true, // Always alert on key rotation
        severity: "info",
        message: (decoded) => `Key rotated for agent ${decoded.agentId}`,
      },
      {
        name: "Agent Deactivation",
        contract: "AgentIdentityRegistry",
        event: "AgentDeactivated",
        condition: () => true,
        severity: "warning",
        message: (decoded) => `Agent deactivated: ${decoded.agentId} by ${decoded.deactivatedBy}`,
      },

      // Reputation System alerts
      {
        name: "Large Slash Event",
        contract: "AgentReputationSystem",
        event: "ReputationSlashed",
        condition: (log, decoded) => decoded.slashedAmount > ethers.parseEther("1"),
        severity: "critical",
        message: (decoded) =>
          `Large slash: ${ethers.formatEther(decoded.slashedAmount)} ETH from agent ${decoded.agentId}`,
      },
      {
        name: "Large Stake Deposit",
        contract: "AgentReputationSystem",
        event: "Staked",
        condition: (log, decoded) => decoded.amount > ethers.parseEther("10"),
        severity: "info",
        message: (decoded) =>
          `Large stake: ${ethers.formatEther(decoded.amount)} ETH by agent ${decoded.agentId}`,
      },
      {
        name: "Rapid Reputation Change",
        contract: "AgentReputationSystem",
        event: "ReputationUpdated",
        condition: (log, decoded) => Math.abs(decoded.change) > 500,
        severity: "warning",
        message: (decoded) =>
          `Rapid reputation change: ${decoded.change} points for agent ${decoded.agentId}`,
      },

      // Security alerts
      {
        name: "Emergency Mode Activated",
        contract: "SecurityConfig",
        event: "EmergencyActivated",
        condition: () => true,
        severity: "critical",
        message: (decoded) => `ðŸš¨ EMERGENCY MODE: ${decoded.reason} by ${decoded.activator}`,
      },
      {
        name: "Agent Blacklisted",
        contract: "SecurityConfig",
        event: "AgentBlacklisted",
        condition: () => true,
        severity: "critical",
        message: (decoded) => `Agent blacklisted: ${decoded.agentId} - ${decoded.reason}`,
      },

      // Circuit Breaker alerts
      {
        name: "Circuit Breaker Tripped",
        contract: "CircuitBreaker",
        event: "CircuitBroken",
        condition: () => true,
        severity: "critical",
        message: (decoded) => `Circuit breaker tripped: ${decoded.reason}`,
      },

      // Cross-chain alerts
      {
        name: "Cross-Chain Sync Failure",
        contract: "CrossChainAgentBridge",
        event: "MessageFailed",
        condition: () => true,
        severity: "critical",
        message: (decoded) =>
          `Cross-chain message failed: ${decoded.srcChainId} â†’ ${decoded.payload}`,
      },
    ];
  }

  async startMonitoring(chains: string[]): Promise<void> {
    for (const chain of chains) {
      const provider = new ethers.WebSocketProvider(process.env[`${chain.toUpperCase()}_WS_URL`]!);
      this.providers.set(chain, provider);

      await this.setupEventListeners(chain, provider);
      console.log(`ðŸ“¡ Monitoring started for ${chain}`);
    }
  }

  private async setupEventListeners(chain: string, provider: ethers.Provider): Promise<void> {
    const deployedContracts = await this.loadDeployedContracts(chain);

    for (const rule of this.rules) {
      const contractAddress = deployedContracts[rule.contract];
      if (!contractAddress) continue;

      const contract = await this.getContract(rule.contract, contractAddress, provider);

      contract.on(rule.event, async (...args) => {
        const event = args[args.length - 1];
        const decoded = this.decodeEvent(contract, rule.event, event);

        if (rule.condition(event, decoded)) {
          await this.sendAlert(chain, rule, decoded);
        }
      });
    }
  }

  private async sendAlert(chain: string, rule: MonitoringRule, decoded: any): Promise<void> {
    const alert = {
      timestamp: new Date().toISOString(),
      chain,
      ruleName: rule.name,
      severity: rule.severity,
      message: rule.message(decoded),
      data: decoded,
    };

    console.log(`[${alert.severity.toUpperCase()}] ${alert.message}`);

    // Send to configured channels
    if (rule.severity === "critical") {
      await Promise.all([
        this.sendPagerDuty(alert),
        this.sendSlack(alert),
        this.sendTelegram(alert),
      ]);
    } else if (rule.severity === "warning") {
      await this.sendSlack(alert);
    }

    // Always log to webhook
    await this.sendWebhook(alert);
  }

  private async sendPagerDuty(alert: any): Promise<void> {
    if (!this.alertConfig.pagerDutyKey) return;

    await fetch("https://events.pagerduty.com/v2/enqueue", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        routing_key: this.alertConfig.pagerDutyKey,
        event_action: "trigger",
        payload: {
          summary: alert.message,
          severity: alert.severity === "critical" ? "critical" : "warning",
          source: `blockchain-monitor-${alert.chain}`,
          custom_details: alert.data,
        },
      }),
    });
  }

  private async sendSlack(alert: any): Promise<void> {
    if (!this.alertConfig.slackChannel) return;

    const emoji = alert.severity === "critical" ? "ðŸš¨" :
                  alert.severity === "warning" ? "âš ï¸" : "â„¹ï¸";

    await fetch(this.alertConfig.webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        channel: this.alertConfig.slackChannel,
        text: `${emoji} *${alert.ruleName}* (${alert.chain})\n${alert.message}`,
        attachments: [{
          color: alert.severity === "critical" ? "#ff0000" :
                 alert.severity === "warning" ? "#ffaa00" : "#00ff00",
          fields: Object.entries(alert.data).map(([k, v]) => ({
            title: k,
            value: String(v),
            short: true,
          })),
        }],
      }),
    });
  }

  private async sendTelegram(alert: any): Promise<void> {
    if (!this.alertConfig.telegramBotToken) return;

    const message = `ðŸ”” *${alert.ruleName}*\n` +
                   `Chain: ${alert.chain}\n` +
                   `Severity: ${alert.severity}\n\n` +
                   `${alert.message}`;

    await fetch(
      `https://api.telegram.org/bot${this.alertConfig.telegramBotToken}/sendMessage`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          chat_id: this.alertConfig.telegramChatId,
          text: message,
          parse_mode: "Markdown",
        }),
      }
    );
  }

  private async sendWebhook(alert: any): Promise<void> {
    await fetch(this.alertConfig.webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(alert),
    });
  }

  // Helper methods
  private eventCountCache: Map<string, number> = new Map();

  private getEventCountInBlock(blockNumber: number, eventName: string): number {
    const key = `${blockNumber}-${eventName}`;
    const count = (this.eventCountCache.get(key) || 0) + 1;
    this.eventCountCache.set(key, count);
    return count;
  }

  private async loadDeployedContracts(chain: string): Promise<Record<string, string>> {
    // Load from deployment artifacts
    const fs = await import("fs/promises");
    const data = await fs.readFile(`./deployments/${chain}.json`, "utf-8");
    return JSON.parse(data);
  }

  private async getContract(name: string, address: string, provider: ethers.Provider): Promise<ethers.Contract> {
    const key = `${name}-${address}`;
    if (!this.contracts.has(key)) {
      const artifact = await import(`../artifacts/contracts/${name}.sol/${name}.json`);
      this.contracts.set(key, new ethers.Contract(address, artifact.abi, provider));
    }
    return this.contracts.get(key)!;
  }

  private decodeEvent(contract: ethers.Contract, eventName: string, log: ethers.Log): any {
    const event = contract.interface.getEvent(eventName);
    if (!event) return {};
    return contract.interface.decodeEventLog(event, log.data, log.topics);
  }
}
```

## Incident Response Procedures

### Incident Classification & Response Matrix

```yaml
# incident-response/playbooks/classification.yaml
severity_levels:
  SEV1_CRITICAL:
    description: "System compromise, active exploit, funds at risk"
    response_time: "< 15 minutes"
    escalation: "Immediate exec notification"
    actions:
      - Activate emergency mode
      - Pause all contracts
      - Notify security team
      - Begin forensic capture
    examples:
      - "Active fund drainage"
      - "Private key compromise suspected"
      - "Reentrancy attack in progress"

  SEV2_HIGH:
    description: "Security vulnerability discovered, potential exploit"
    response_time: "< 1 hour"
    escalation: "Security lead notification"
    actions:
      - Assess vulnerability scope
      - Prepare emergency patch
      - Monitor for exploitation
      - Notify affected parties if public
    examples:
      - "Critical bug in reputation slashing"
      - "ZK proof verification bypass found"
      - "Cross-chain message spoofing possible"

  SEV3_MEDIUM:
    description: "Service degradation, non-critical bugs"
    response_time: "< 4 hours"
    escalation: "On-call engineer"
    actions:
      - Investigate root cause
      - Implement fix
      - Deploy to staging
      - Schedule production deployment
    examples:
      - "High gas costs from inefficient code"
      - "UI showing incorrect reputation"
      - "Delayed cross-chain sync"

  SEV4_LOW:
    description: "Minor issues, cosmetic bugs"
    response_time: "< 24 hours"
    escalation: "Ticket creation"
    actions:
      - Document issue
      - Add to backlog
      - Schedule for next sprint
    examples:
      - "Event emission missing field"
      - "Documentation outdated"
      - "Test coverage gap"
```

### Automated Incident Response

```typescript
// incident-response/AutomatedResponse.ts
import { ethers } from "ethers";

interface Incident {
  id: string;
  severity: "SEV1" | "SEV2" | "SEV3" | "SEV4";
  type: IncidentType;
  detectedAt: Date;
  chain: string;
  contractAddress: string;
  description: string;
  evidence: any[];
}

enum IncidentType {
  REENTRANCY_ATTEMPT = "REENTRANCY_ATTEMPT",
  UNAUTHORIZED_ACCESS = "UNAUTHORIZED_ACCESS",
  ANOMALOUS_ACTIVITY = "ANOMALOUS_ACTIVITY",
  FUND_DRAINAGE = "FUND_DRAINAGE",
  ORACLE_MANIPULATION = "ORACLE_MANIPULATION",
  FLASH_LOAN_ATTACK = "FLASH_LOAN_ATTACK",
  SYBIL_ATTACK = "SYBIL_ATTACK",
}

export class IncidentResponder {
  private emergencyWallet: ethers.Wallet;
  private contracts: Map<string, ethers.Contract> = new Map();

  constructor(emergencyKey: string) {
    this.emergencyWallet = new ethers.Wallet(emergencyKey);
  }

  async handleIncident(incident: Incident): Promise<ResponseReport> {
    const report: ResponseReport = {
      incidentId: incident.id,
      startTime: new Date(),
      actions: [],
      status: "IN_PROGRESS",
    };

    try {
      // Step 1: Initial Assessment
      const assessment = await this.assessIncident(incident);
      report.actions.push({ step: "assessment", result: assessment });

      // Step 2: Automated Response based on severity
      if (incident.severity === "SEV1") {
        await this.executeSev1Response(incident, report);
      } else if (incident.severity === "SEV2") {
        await this.executeSev2Response(incident, report);
      }

      // Step 3: Evidence Collection
      const evidence = await this.collectEvidence(incident);
      report.actions.push({ step: "evidence_collection", result: evidence });

      // Step 4: Notification
      await this.notifyStakeholders(incident, report);

      report.status = "CONTAINED";
      report.endTime = new Date();

    } catch (error) {
      report.status = "FAILED";
      report.error = error instanceof Error ? error.message : String(error);
      // Escalate to human responder
      await this.escalateToHuman(incident, report);
    }

    return report;
  }

  private async executeSev1Response(incident: Incident, report: ResponseReport): Promise<void> {
    // 1. Activate Emergency Mode
    const securityConfig = await this.getContract("SecurityConfig", incident.chain);
    const emergencyTx = await securityConfig.connect(this.emergencyWallet)
      .activateEmergency(`Automated response to ${incident.type}`);
    await emergencyTx.wait();
    report.actions.push({
      step: "emergency_activated",
      txHash: emergencyTx.hash
    });

    // 2. Pause affected contracts
    const pausableTx = await this.pauseContract(incident.contractAddress, incident.chain);
    report.actions.push({
      step: "contract_paused",
      txHash: pausableTx.hash
    });

    // 3. If fund drainage, attempt to rescue
    if (incident.type === IncidentType.FUND_DRAINAGE) {
      const rescueResult = await this.attemptFundRescue(incident);
      report.actions.push({ step: "fund_rescue_attempt", result: rescueResult });
    }

    // 4. Blacklist suspicious addresses
    if (incident.evidence.some(e => e.type === "suspicious_address")) {
      const suspiciousAddrs = incident.evidence
        .filter(e => e.type === "suspicious_address")
        .map(e => e.address);

      for (const addr of suspiciousAddrs) {
        await securityConfig.connect(this.emergencyWallet)
          .blacklistAddress(addr, `Automated blacklist: ${incident.id}`);
      }
      report.actions.push({ step: "addresses_blacklisted", count: suspiciousAddrs.length });
    }

    // 5. Trigger circuit breaker for related operations
    const circuitBreaker = await this.getContract("CircuitBreaker", incident.chain);
    await circuitBreaker.connect(this.emergencyWallet)
      .tripBreaker(this.getOperationType(incident.type), incident.description);
    report.actions.push({ step: "circuit_breaker_tripped" });
  }

  private async executeSev2Response(incident: Incident, report: ResponseReport): Promise<void> {
    // 1. Enable enhanced monitoring
    await this.enableEnhancedMonitoring(incident);
    report.actions.push({ step: "enhanced_monitoring_enabled" });

    // 2. Rate limit suspicious operations
    const securityConfig = await this.getContract("SecurityConfig", incident.chain);
    await securityConfig.connect(this.emergencyWallet)
      .setRateLimit(
        this.getAffectedSelector(incident.type),
        1, // 1 per block
        10, // 10 per hour
        300 // 5 min cooldown
      );
    report.actions.push({ step: "rate_limits_applied" });

    // 3. Prepare but don't execute emergency pause
    const pauseCalldata = securityConfig.interface.encodeFunctionData("activateEmergency", [
      `Prepared response to ${incident.type}`
    ]);
    report.actions.push({
      step: "emergency_prepared",
      calldata: pauseCalldata,
      note: "Ready to execute if situation escalates"
    });
  }

  private async collectEvidence(incident: Incident): Promise<EvidencePackage> {
    const provider = this.getProvider(incident.chain);

    // Get transaction history around incident
    const currentBlock = await provider.getBlockNumber();
    const startBlock = currentBlock - 1000; // Last ~1000 blocks

    const logs = await provider.getLogs({
      address: incident.contractAddress,
      fromBlock: startBlock,
      toBlock: currentBlock,
    });

    // Get state at time of incident
    const contract = await this.getContract("AgentIdentityRegistry", incident.chain);
    const storageSnapshot = await this.captureStorageSnapshot(contract);

    // Get mempool data if available
    const mempoolData = await this.getMempoolData(incident.chain);

    return {
      logs,
      storageSnapshot,
      mempoolData,
      blockRange: { start: startBlock, end: currentBlock },
      capturedAt: new Date(),
    };
  }

  private async attemptFundRescue(incident: Incident): Promise<RescueResult> {
    // Check if rescue is possible (e.g., funds still in contract)
    const provider = this.getProvider(incident.chain);
    const balance = await provider.getBalance(incident.contractAddress);

    if (balance === 0n) {
      return { success: false, reason: "No funds remaining in contract" };
    }

    // Execute rescue to secure multisig
    const secureMultisig = process.env.EMERGENCY_MULTISIG!;

    // This would require a rescue function in the contract
    const contract = await this.getContract("AgentReputationSystem", incident.chain);

    try {
      const tx = await contract.connect(this.emergencyWallet)
        .emergencyWithdraw(secureMultisig);
      const receipt = await tx.wait();

      return {
        success: true,
        txHash: receipt.hash,
        amountRescued: ethers.formatEther(balance),
      };
    } catch (error) {
      return {
        success: false,
        reason: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  private async assessIncident(incident: Incident): Promise<Assessment> {
    // Analyze incident patterns
    const patterns = this.analyzePatterns(incident);

    // Check for known attack signatures
    const knownAttack = this.matchKnownAttack(patterns);

    // Estimate impact
    const impact = await this.estimateImpact(incident);

    return {
      patterns,
      knownAttack,
      impact,
      recommendedActions: this.getRecommendedActions(patterns, knownAttack, impact),
    };
  }

  // Helper methods
  private getOperationType(incidentType: IncidentType): number {
    const mapping: Record<IncidentType, number> = {
      [IncidentType.REENTRANCY_ATTEMPT]: 0,
      [IncidentType.UNAUTHORIZED_ACCESS]: 1,
      [IncidentType.ANOMALOUS_ACTIVITY]: 2,
      [IncidentType.FUND_DRAINAGE]: 3,
      [IncidentType.ORACLE_MANIPULATION]: 4,
      [IncidentType.FLASH_LOAN_ATTACK]: 5,
      [IncidentType.SYBIL_ATTACK]: 6,
    };
    return mapping[incidentType] ?? 0;
  }

  private getAffectedSelector(incidentType: IncidentType): string {
    const mapping: Record<IncidentType, string> = {
      [IncidentType.REENTRANCY_ATTEMPT]: "0x", // withdraw
      [IncidentType.UNAUTHORIZED_ACCESS]: "0x", // all admin functions
      [IncidentType.ANOMALOUS_ACTIVITY]: "0x", // varies
      [IncidentType.FUND_DRAINAGE]: "0x", // withdraw/transfer
      [IncidentType.ORACLE_MANIPULATION]: "0x", // price updates
      [IncidentType.FLASH_LOAN_ATTACK]: "0x", // flash loan callbacks
      [IncidentType.SYBIL_ATTACK]: "0x", // registration
    };
    return mapping[incidentType] ?? "0x00000000";
  }

  // ... additional helper implementations
}

interface ResponseReport {
  incidentId: string;
  startTime: Date;
  endTime?: Date;
  actions: Array<{ step: string; [key: string]: any }>;
  status: "IN_PROGRESS" | "CONTAINED" | "FAILED" | "ESCALATED";
  error?: string;
}

interface EvidencePackage {
  logs: ethers.Log[];
  storageSnapshot: any;
  mempoolData: any;
  blockRange: { start: number; end: number };
  capturedAt: Date;
}

interface RescueResult {
  success: boolean;
  reason?: string;
  txHash?: string;
  amountRescued?: string;
}

interface Assessment {
  patterns: string[];
  knownAttack: string | null;
  impact: { financial: string; operational: string; reputational: string };
  recommendedActions: string[];
}
```

## Post-Incident Analysis

### Forensic Analysis Template

```markdown
# Incident Post-Mortem: [INCIDENT_ID]

## Executive Summary
- **Date/Time**: [TIMESTAMP]
- **Duration**: [DURATION]
- **Severity**: [SEV1-4]
- **Financial Impact**: [AMOUNT]
- **Root Cause**: [BRIEF_DESCRIPTION]

## Timeline
| Time (UTC) | Event | Source |
|------------|-------|--------|
| HH:MM | First anomaly detected | Monitoring |
| HH:MM | Alert triggered | PagerDuty |
| HH:MM | Response team assembled | Manual |
| HH:MM | Emergency mode activated | Automated |
| HH:MM | Incident contained | Manual |
| HH:MM | Services restored | Manual |

## Technical Analysis

### Attack Vector
[Detailed description of how the incident occurred]

### Affected Components
- [ ] AgentIdentityRegistry
- [ ] AgentReputationSystem
- [ ] AgentCredentialVerifier
- [ ] CrossChainAgentBridge
- [ ] Other: [SPECIFY]

### Evidence
```
Transaction Hash: 0x...
Block Number: ...
Attacker Address: 0x...
Affected Agents: [LIST]
```

### Root Cause
[Detailed technical explanation]

## Impact Assessment

### Financial
- Funds lost: [AMOUNT]
- Funds at risk (prevented): [AMOUNT]
- Recovery possibility: [YES/NO/PARTIAL]

### Operational
- Service downtime: [DURATION]
- Agents affected: [COUNT]
- Cross-chain sync status: [STATUS]

### Reputational
- Public disclosure required: [YES/NO]
- User notifications sent: [YES/NO]
- Media coverage: [LINKS]

## Response Evaluation

### What Worked Well
1. [ITEM]
2. [ITEM]

### What Could Be Improved
1. [ITEM]
2. [ITEM]

## Action Items

### Immediate (0-24 hours)
- [ ] [ACTION_ITEM]
- [ ] [ACTION_ITEM]

### Short-term (1-7 days)
- [ ] [ACTION_ITEM]
- [ ] [ACTION_ITEM]

### Long-term (1-4 weeks)
- [ ] [ACTION_ITEM]
- [ ] [ACTION_ITEM]

## Lessons Learned
[Key takeaways and how they will improve future response]

## Appendix
- Full transaction logs
- Communication logs
- Evidence archive location
```

## Upgrade Procedures

### Safe Upgrade Workflow

```typescript
// upgrade/SafeUpgradeManager.ts
import { ethers } from "ethers";
import { TimelockController } from "@openzeppelin/contracts";

export class SafeUpgradeManager {
  private timelock: ethers.Contract;
  private proxyAdmin: ethers.Contract;

  async proposeUpgrade(
    proxyAddress: string,
    newImplementation: string,
    migrationData: string = "0x"
  ): Promise<UpgradeProposal> {
    // 1. Verify new implementation
    const verificationResult = await this.verifyImplementation(newImplementation);
    if (!verificationResult.passed) {
      throw new Error(`Implementation verification failed: ${verificationResult.errors.join(", ")}`);
    }

    // 2. Simulate upgrade
    const simulationResult = await this.simulateUpgrade(proxyAddress, newImplementation, migrationData);
    if (!simulationResult.success) {
      throw new Error(`Upgrade simulation failed: ${simulationResult.error}`);
    }

    // 3. Create timelock proposal
    const upgradeCalldata = this.proxyAdmin.interface.encodeFunctionData(
      "upgradeAndCall",
      [proxyAddress, newImplementation, migrationData]
    );

    const proposalId = await this.timelock.hashOperation(
      await this.proxyAdmin.getAddress(),
      0,
      upgradeCalldata,
      ethers.ZeroHash,
      ethers.id(`upgrade-${proxyAddress}-${Date.now()}`)
    );

    // 4. Schedule the proposal
    const delay = await this.timelock.getMinDelay();
    await this.timelock.schedule(
      await this.proxyAdmin.getAddress(),
      0,
      upgradeCalldata,
      ethers.ZeroHash,
      ethers.id(`upgrade-${proxyAddress}-${Date.now()}`),
      delay
    );

    return {
      proposalId,
      proxyAddress,
      newImplementation,
      executionTime: Date.now() + Number(delay) * 1000,
      verification: verificationResult,
      simulation: simulationResult,
    };
  }

  private async verifyImplementation(implementation: string): Promise<VerificationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check bytecode matches expected
    const bytecode = await ethers.provider.getCode(implementation);
    if (bytecode === "0x") {
      errors.push("Implementation not deployed");
    }

    // Verify no selfdestruct
    if (bytecode.includes("ff")) {
      warnings.push("Potential selfdestruct opcode detected");
    }

    // Verify storage layout compatibility
    // This would use OpenZeppelin upgrade-safe checks in practice

    // Verify initializer protection
    // Check for initializer modifier on all init functions

    return {
      passed: errors.length === 0,
      errors,
      warnings,
    };
  }

  private async simulateUpgrade(
    proxyAddress: string,
    newImplementation: string,
    migrationData: string
  ): Promise<SimulationResult> {
    try {
      // Fork mainnet and simulate
      const forkUrl = process.env.FORK_RPC_URL;

      // Use hardhat_impersonateAccount to simulate as timelock
      // Execute upgrade on fork
      // Run test suite against upgraded contracts

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  async executeUpgrade(proposalId: string): Promise<string> {
    // Verify timelock delay has passed
    const isReady = await this.timelock.isOperationReady(proposalId);
    if (!isReady) {
      throw new Error("Timelock delay not elapsed");
    }

    // Execute
    const tx = await this.timelock.execute(
      // ... proposal details
    );

    return tx.hash;
  }
}

interface UpgradeProposal {
  proposalId: string;
  proxyAddress: string;
  newImplementation: string;
  executionTime: number;
  verification: VerificationResult;
  simulation: SimulationResult;
}

interface VerificationResult {
  passed: boolean;
  errors: string[];
  warnings: string[];
}

interface SimulationResult {
  success: boolean;
  error?: string;
}
```

## Integration with Multi-Agent Systems

### Agent System Deployment Hook

```typescript
// integration/AgentSystemHook.ts
import { MultiAgentOrchestrator } from "@21-multiagent-learning-system";

export class BlockchainAgentHook {
  private identityRegistry: ethers.Contract;
  private reputationSystem: ethers.Contract;

  /**
   * Called when a new agent is spawned in the multi-agent system
   * Registers the agent on-chain for identity verification
   */
  async onAgentSpawn(agent: AgentConfig): Promise<void> {
    const agentId = ethers.keccak256(ethers.toUtf8Bytes(agent.id));
    const metadataHash = ethers.keccak256(
      ethers.toUtf8Bytes(JSON.stringify({
        name: agent.name,
        capabilities: agent.capabilities,
        version: agent.version,
      }))
    );

    // Register on-chain
    await this.identityRegistry.registerAgent(
      agentId,
      metadataHash,
      [agent.owner] // Recovery address
    );

    // Initial stake
    await this.reputationSystem.stake(agentId, {
      value: ethers.parseEther("0.1"),
    });

    console.log(`Agent ${agent.id} registered on-chain: ${agentId}`);
  }

  /**
   * Called after agent completes a task
   * Updates on-chain reputation based on performance
   */
  async onTaskComplete(
    agentId: string,
    task: TaskResult
  ): Promise<void> {
    const onChainId = ethers.keccak256(ethers.toUtf8Bytes(agentId));

    if (task.success) {
      await this.reputationSystem.addReputation(
        onChainId,
        this.mapCategoryToEnum(task.category),
        task.score,
        task.evidence
      );
    } else {
      // Slash for failed task
      await this.reputationSystem.slash(
        onChainId,
        this.mapCategoryToEnum(task.category),
        1, // Minor severity
        `Task failed: ${task.failureReason}`
      );
    }
  }

  /**
   * Verify agent credentials before allowing sensitive operations
   */
  async verifyAgentCredentials(
    agentId: string,
    requiredCapability: string,
    minTrustLevel: number
  ): Promise<boolean> {
    const onChainId = ethers.keccak256(ethers.toUtf8Bytes(agentId));

    // Check on-chain identity
    const identity = await this.identityRegistry.agents(onChainId);
    if (!identity.isActive) {
      return false;
    }

    // Check trust tier
    if (identity.trustTier < minTrustLevel) {
      return false;
    }

    // Verify capability credential (ZK proof)
    // This would integrate with the ZK verification system

    return true;
  }

  private mapCategoryToEnum(category: string): number {
    const mapping: Record<string, number> = {
      "task_completion": 0,
      "response_quality": 1,
      "security_compliance": 2,
      "collaboration": 3,
      "reliability": 4,
    };
    return mapping[category] ?? 0;
  }
}

// Usage in multi-agent orchestrator
const hook = new BlockchainAgentHook();

orchestrator.on("agent:spawn", hook.onAgentSpawn.bind(hook));
orchestrator.on("task:complete", hook.onTaskComplete.bind(hook));
orchestrator.addMiddleware("sensitive:operation", async (ctx, next) => {
  const verified = await hook.verifyAgentCredentials(
    ctx.agentId,
    ctx.requiredCapability,
    ctx.minTrustLevel
  );
  if (!verified) {
    throw new Error("Agent credentials verification failed");
  }
  return next();
});
```

---

## Summary Checklist

### Pre-Deployment
- [ ] All contracts audited by reputable firm
- [ ] Formal verification completed for critical functions
- [ ] Invariant tests passing with 100% coverage
- [ ] Gas optimization completed
- [ ] Multi-sig wallets configured
- [ ] Timelock delays appropriate for each chain
- [ ] Emergency procedures documented and tested

### Deployment
- [ ] Deterministic addresses via CREATE2
- [ ] Cross-chain links configured
- [ ] Ownership transferred to timelock
- [ ] All contracts verified on block explorers
- [ ] Monitoring infrastructure live
- [ ] Alerting channels configured

### Post-Deployment
- [ ] Smoke tests passing on all chains
- [ ] Integration tests with multi-agent system
- [ ] Incident response team on standby
- [ ] Runbooks accessible to all responders
- [ ] Communication channels ready
- [ ] User documentation published

---

*This SKILL integrates with [21-multiagent-learning-system](../21-multiagent-learning-system/SKILL.md) for comprehensive AI agent blockchain infrastructure.*
