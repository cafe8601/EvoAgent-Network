# L2: Agent Orchestration, Selection & Memory System

## Agent Pool Management

### Agent Status Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Agent Instance Lifecycle                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    [RESERVED] â”€â”€â”€â”€â”€â”€â†’ [WORKING] â”€â”€â”€â”€â”€â”€â†’ [IDLE]                  â”‚
â”‚         â”‚                  â”‚               â”‚                     â”‚
â”‚         â”‚                  â–¼               â–¼                     â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [TERMINATED] â†â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                    (cleanup/timeout)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
from big_three_realtime_agents.agents.pool import (
    AgentPoolManager,
    AgentStatus,
    AgentInstance,
    ExpertDefinition,
)

pool = AgentPoolManager()

# List available expert types
experts = pool.list_expert_types()
# [
#     {"expert_id": "BackendArchitect", "name": "Backend Architect", ...},
#     {"expert_id": "FrontendDeveloper", "name": "Frontend Developer", ...},
# ]

# Acquire expert instance
instance = await pool.acquire_expert(
    expert_id="BackendArchitect",
    task_description="Design REST API",
    prefer_reuse=True  # Try to reuse idle instances
)

# Mark as working
pool.mark_working(instance.instance_id)

# Execute task...

# Release back to pool
pool.release_instance(
    instance_id=instance.instance_id,
    task_result="Created 5 API endpoints"
)

# Cleanup old idle instances
cleaned = pool.cleanup_idle_instances(max_idle_time_seconds=3600)

# Get pool statistics
stats = pool.get_stats()
# {"total_instances": 5, "by_status": {"idle": 2, "working": 3, ...}}
```

---

## Intelligent Agent Selection

### Trigger-Based Matching

```python
from big_three_realtime_agents.agents.pool import (
    IntelligentAgentSelector,
    ExpertDefinition,
    AgentTier,
)

# Expert definition structure
expert = ExpertDefinition(
    agent_id="backend-architect",
    name="Backend Architect",
    tier=AgentTier.TIER1,
    category="architecture",
    description="Design reliable backend systems with focus on data integrity",
    triggers=["backend", "API", "database", "REST", "GraphQL"],
    focus_areas=["security", "performance", "scalability"],
    system_prompt_path="agentpool/tier1-core/backend-architect.md",
)

# Initialize selector
selector = IntelligentAgentSelector(expert_definitions)

# Single best agent
agent_id = selector.select_best_agent("Build REST API with auth")

# Multiple agents for complex tasks
agents = selector.select_multiple_agents(
    task="Full-stack e-commerce platform",
    max_agents=3,
    min_score=0.3
)
# ["fullstack-developer", "backend-architect", "frontend-developer"]

# Explain selection
explanation = selector.explain_selection("backend-architect", task)
```

### Scoring Algorithm

```
Score Calculation:
â”œâ”€ Trigger Match (weight: 3.0)    â†’ Exact keyword match
â”œâ”€ Trigger Partial (weight: 1.0)  â†’ Word-level match
â”œâ”€ Description Overlap (0.5/word) â†’ Word intersection
â”œâ”€ Category Match (weight: 1.0)   â†’ Category in task
â”œâ”€ Focus Areas (weight: 2.0)      â†’ Area keyword match
â””â”€ Context Bonus (weight: 1.0)    â†’ Additional context match
```

---

## Memory System Details

### Session Memory (In-Memory)

```python
from big_three_realtime_agents.memory import SessionMemory

session = SessionMemory()

# Basic operations
session.set("current_task", task_data)
task = session.get("current_task")

# Get all data
all_data = session.get_all()

# Clear session
session.clear()
```

### Workflow Memory (Persistent)

```python
from big_three_realtime_agents.memory import WorkflowMemory

workflow_mem = WorkflowMemory(storage_dir="./workflows")

# Store execution
workflow_mem.store_execution("workflow_123", {
    "plan_id": "plan_abc",
    "stages_completed": 2,
    "results": [...]
})

# Retrieve execution
execution = workflow_mem.get_execution("workflow_123")

# Get recent workflows
recent = workflow_mem.get_recent(limit=5)

# Count stored workflows
count = workflow_mem.count()
```

### Context Store (Long-Term)

```python
from big_three_realtime_agents.memory import ContextStore

context = ContextStore(storage_dir="./context")

# Save project context
context.save_context("project_patterns", {
    "architecture": "microservices",
    "language": "Python",
    "frameworks": ["FastAPI", "SQLAlchemy"],
})

# Load context
patterns = context.load_context("project_patterns")

# List all contexts
available = context.list_contexts()
```

---

## Workflow Planning

### Execution Strategies

```python
from big_three_realtime_agents.workflow import (
    WorkflowPlanner,
    ExecutionStrategy,
    WorkflowPlan,
    WorkflowTask,
)

planner = WorkflowPlanner(pool_manager, memory)

# Simple single-task plan
simple_plan = planner.create_simple_plan(
    task_description="Build user API",
    agent_id="backend-architect",
    strategy=ExecutionStrategy.SEQUENTIAL
)

# Multi-task plan
multi_plan = planner.create_multi_task_plan(
    goal="Build e-commerce backend",
    tasks=[
        {"description": "Design database schema", "agent_id": "data-engineer", "duration": 180},
        {"description": "Create REST endpoints", "agent_id": "backend-architect", "duration": 300},
        {"description": "Write tests", "agent_id": "qa-expert", "duration": 120, "dependencies": ["task_2"]},
    ],
    strategy=ExecutionStrategy.SEQUENTIAL
)

# Visualize plan
print(planner.visualize_plan(multi_plan))
```

### Workflow Visualization Output

```
============================================================
WORKFLOW PLAN: Build e-commerce backend
============================================================
Plan ID: plan_a1b2c3d4
Estimated Duration: 600s
Total Stages: 1
Total Tasks: 3

[Stage 1] Multi-Task Execution
  Strategy: sequential
  Tasks: 3

    1. [data-engineer] Design database schema
       Duration: ~180s
    2. [backend-architect] Create REST endpoints
       Duration: ~300s
    3. [qa-expert] Write tests (depends: task_2)
       Duration: ~120s

Success Criteria: All tasks completed successfully
============================================================
```

---

## Learning System Integration

### Outcome Tracking

```python
from big_three_realtime_agents.learning import (
    LearningManager,
    OutcomeTracker,
    PatternAnalyzer,
)

learning = LearningManager(storage_dir="./learning")

# Record success
learning.record_task_outcome(
    task="Implement OAuth2",
    agent_id="security-engineer",
    result={
        "status": "success",
        "duration": 245,
        "files_modified": ["auth.py", "config.py"],
    },
    success=True
)

# Record failure
learning.record_task_outcome(
    task="Deploy to Kubernetes",
    agent_id="devops-engineer",
    result={"error": "Helm chart validation failed"},
    success=False
)
```

### Pattern Analysis

```python
# Get learning statistics
stats = learning.get_learning_stats()
# {
#     "total_outcomes": 150,
#     "agents_tracked": 25,
#     "top_keywords": [("api", 45), ("auth", 32), ("database", 28)],
#     "agent_performance": {
#         "backend-architect": {"success": 45, "fail": 3, "rate": 0.94},
#         "devops-engineer": {"success": 38, "fail": 8, "rate": 0.83},
#     }
# }

# Get recommendations
recommendations = learning.get_recommendations("Build authentication system")
# {
#     "recommended_agent": "security-engineer",
#     "confidence": 0.87,
#     "reason": "security-engineer has 87% success rate on similar tasks",
#     "similar_tasks": [
#         {"task": "Implement OAuth2", "agent": "security-engineer", "status": "success"},
#         {"task": "Add JWT validation", "agent": "security-engineer", "status": "success"},
#     ]
# }
```

### Combined Selection (Learning + Pool)

```python
# Best of both worlds
best_agent = learning.suggest_agent_for_task(
    task="Implement rate limiting",
    pool_selector=selector
)

# Logic:
# 1. Check historical performance (confidence > 0.7 â†’ use history)
# 2. Otherwise use intelligent pool selection
# 3. Fall back to history if pool returns None
```

---

## Agent Definition Structure

### Tier 1 Agent Template

```markdown
---
name: backend-architect
description: Design reliable backend systems with focus on data integrity
tier: 1
category: architecture
triggers:
  - backend
  - API
  - REST
  - GraphQL
  - database
  - microservices
focus_areas:
  - security
  - performance
  - scalability
  - fault-tolerance
tools:
  - Read
  - Write
  - Edit
  - Bash
  - Grep
  - Glob
---

## Role
Expert backend system designer specializing in reliable, scalable architectures.

## System Prompt
You are a senior backend architect with expertise in:
- RESTful and GraphQL API design
- Database schema optimization
- Microservices architecture
- Security best practices

## Guidelines
1. Always consider data integrity and consistency
2. Design for horizontal scalability
3. Implement proper error handling
4. Follow security-first principles
```

---

## Real-Time Orchestration

### OpenAI Realtime Agent (Orchestrator)

```python
from big_three_realtime_agents.agents.openai import (
    RealtimeAgent,
    SessionConfig,
)

# Configure orchestrator session
config = SessionConfig(
    model="gpt-4o-realtime-preview-2024-12-17",
    voice="alloy",
    modalities=["text", "audio"],
    temperature=0.6,
)

# Initialize orchestrator
orchestrator = RealtimeAgent(config)

# Register function tools
orchestrator.register_tool(
    name="delegate_to_claude",
    description="Delegate coding task to Claude Coder",
    parameters={...},
    handler=claude_delegation_handler
)

orchestrator.register_tool(
    name="delegate_to_gemini",
    description="Delegate browser task to Gemini Browser",
    parameters={...},
    handler=gemini_delegation_handler
)

# Start session (WebSocket)
await orchestrator.connect()
await orchestrator.start_session()
```

---

## RAG System (Retrieval-Augmented Generation)

### Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      RAG System Architecture                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  User Query â”€â”€â†’ Embedding â”€â”€â†’ Vector Search â”€â”€â†’ Context         â”‚
â”‚                    â”‚              â”‚                â”‚             â”‚
â”‚                    â–¼              â–¼                â–¼             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚         â”‚ Sentence     â”‚  â”‚  ChromaDB   â”‚  â”‚  Augmented  â”‚      â”‚
â”‚         â”‚ Transformer  â”‚  â”‚  Collections â”‚  â”‚  Response   â”‚      â”‚
â”‚         â”‚ all-MiniLM   â”‚  â”‚  code/exp   â”‚  â”‚             â”‚      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Components

```python
from big_three_realtime_agents.rag import RAGSystem

# Initialize with Memory Manager
rag = RAGSystem(memory_manager=memory)

# Custom embedding model (optional)
rag_custom = RAGSystem(
    memory_manager=memory,
    embedding_model="all-MiniLM-L6-v2"  # Default
)
```

### Code Indexing

```python
# Index single code file
rag.index_code(
    code_path="src/auth/oauth.py",
    content=file_content,
    metadata={
        "language": "python",
        "module": "auth",
        "author": "team-security",
    }
)

# Index entire codebase
from pathlib import Path

rag.index_codebase(Path("./src"))
# Automatically:
# - Scans all Python files
# - Extracts content and metadata
# - Creates embeddings
# - Stores in ChromaDB code_collection
```

### Code Search

```python
# Semantic search for relevant code
results = rag.search_code(
    query="JWT token validation middleware",
    limit=5
)
# Returns:
# [
#     {
#         "code_path": "src/auth/jwt.py",
#         "content": "def validate_token(token: str)...",
#         "metadata": {"language": "python", ...},
#         "similarity_score": 0.89
#     },
#     ...
# ]
```

### Experience Indexing & Search

```python
# Index successful task experience
rag.index_experience({
    "task": "Implement OAuth2 with Google",
    "agent_id": "security-engineer",
    "outcome": "success",
    "approach": "Used authlib with FastAPI integration",
    "files_modified": ["auth.py", "routes.py"],
    "duration": 320,
})

# Search similar experiences
similar = rag.search_similar_experiences(
    query="Social login implementation",
    limit=3
)
# Returns past successful approaches for similar tasks
```

### Query Augmentation

```python
# Full RAG-augmented query
augmented = await rag.augment_query(
    user_query="How do we handle authentication?",
    context_type="auto"  # "code", "experience", or "auto"
)
# Returns:
# {
#     "original_query": "How do we handle authentication?",
#     "relevant_code": [...],
#     "similar_experiences": [...],
#     "augmented_context": "Based on existing code and past experiences...",
# }
```

### Task-Specific Retrieval

```python
# Get context for specific expert task
context = await rag.retrieve_for_task(
    task_description="Add rate limiting to API endpoints",
    expert_type="backend-architect"
)
# {
#     "code_context": [...],  # Relevant existing code
#     "experience_context": [...],  # Past similar tasks
#     "recommended_approach": "...",  # AI-synthesized suggestion
# }
```

---

## Google File Search Integration

### Hybrid RAG Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Hybrid RAG Architecture                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Query â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚              â”‚                  â”‚                               â”‚
â”‚              â–¼                  â–¼                               â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚       â”‚  Local    â”‚      â”‚  Google         â”‚                   â”‚
â”‚       â”‚  ChromaDB â”‚      â”‚  File Search    â”‚                   â”‚
â”‚       â”‚ (in-mem)  â”‚      â”‚ (persistent)    â”‚                   â”‚
â”‚       â”‚  ~100ms   â”‚      â”‚  ~500ms         â”‚                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚             â”‚                    â”‚                              â”‚
â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â”‚                      â–¼                                          â”‚
â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚             â”‚  Result Fusion  â”‚                                â”‚
â”‚             â”‚ (RRF Algorithm) â”‚                                â”‚
â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                      â–¼                                          â”‚
â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚             â”‚ Augmented       â”‚                                â”‚
â”‚             â”‚ Context         â”‚                                â”‚
â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Google File Search Setup

```python
from google import genai
from google.genai import types

# Initialize Google GenAI client
client = genai.Client(api_key=os.environ["GOOGLE_API_KEY"])

# Create File Search corpus (10GB FREE storage)
corpus = client.corpora.create(
    display_name="multiagent-knowledge-base",
    description="Code, docs, and experience knowledge base"
)

# Upload documents to corpus
async def upload_to_google_search(file_path: str, content: str):
    """Upload document to Google File Search."""
    document = client.corpora.documents.create(
        corpus=corpus.name,
        document={
            "display_name": Path(file_path).name,
            "raw_document": {
                "content": content.encode("utf-8"),
                "mime_type": "text/plain",
            },
        },
    )
    return document
```

### Hybrid Search Implementation

```python
class HybridRAGSystem:
    """
    Combines local ChromaDB (fast) with Google File Search (powerful).

    Strategy:
    - ChromaDB: Hot data, frequently accessed code
    - Google: Cold data, documentation, historical experiences
    """

    def __init__(
        self,
        local_rag: RAGSystem,
        google_corpus_name: str,
        fusion_k: int = 60,  # RRF parameter
    ):
        self.local = local_rag
        self.google_client = genai.Client()
        self.corpus_name = google_corpus_name
        self.fusion_k = fusion_k

    async def hybrid_search(
        self,
        query: str,
        limit: int = 10,
        source_weights: dict = None,
    ) -> List[Dict]:
        """
        Search both local and Google, fuse results.

        Args:
            query: Search query
            limit: Max results
            source_weights: {"local": 0.4, "google": 0.6}
        """
        weights = source_weights or {"local": 0.4, "google": 0.6}

        # Parallel search
        local_task = asyncio.create_task(
            asyncio.to_thread(self.local.search_code, query, limit)
        )
        google_task = asyncio.create_task(
            self._google_search(query, limit)
        )

        local_results, google_results = await asyncio.gather(
            local_task, google_task
        )

        # Reciprocal Rank Fusion
        fused = self._rrf_fusion(
            local_results, google_results, weights
        )

        return fused[:limit]

    async def _google_search(self, query: str, limit: int) -> List[Dict]:
        """Search Google File Search corpus."""
        response = self.google_client.corpora.query(
            corpus=self.corpus_name,
            query=query,
            results_count=limit,
        )

        return [
            {
                "path": chunk.document.display_name,
                "content": chunk.text,
                "score": chunk.relevance_score,
                "source": "google",
            }
            for chunk in response.relevant_chunks
        ]

    def _rrf_fusion(
        self,
        local: List[Dict],
        google: List[Dict],
        weights: dict,
    ) -> List[Dict]:
        """
        Reciprocal Rank Fusion algorithm.

        RRF score = Î£ (weight / (k + rank))
        """
        scores = {}

        for rank, item in enumerate(local):
            key = item["path"]
            scores[key] = scores.get(key, 0) + (
                weights["local"] / (self.fusion_k + rank + 1)
            )
            scores[key + "_item"] = item

        for rank, item in enumerate(google):
            key = item["path"]
            scores[key] = scores.get(key, 0) + (
                weights["google"] / (self.fusion_k + rank + 1)
            )
            if key + "_item" not in scores:
                scores[key + "_item"] = item

        # Sort by fused score
        results = [
            {**scores[k + "_item"], "fused_score": scores[k]}
            for k in scores
            if not k.endswith("_item")
        ]
        results.sort(key=lambda x: x["fused_score"], reverse=True)

        return results
```

### When to Use Each

| Scenario | Recommended | Reason |
|----------|-------------|--------|
| Hot code search | Local ChromaDB | ~100ms latency |
| Documentation search | Google File Search | Better for large docs |
| Historical experiences | Google File Search | Persistent storage |
| Real-time autocomplete | Local ChromaDB | Speed critical |
| Cross-project search | Google File Search | 10GB shared storage |
| Offline operation | Local ChromaDB | No network needed |

---

## Learning System Integration

### Outcome Tracking

```python
from big_three_realtime_agents.learning import (
    LearningManager,
    OutcomeTracker,
    PatternAnalyzer,
)

learning = LearningManager(storage_dir="./learning")

# Record success
learning.record_task_outcome(
    task="Implement OAuth2",
    agent_id="security-engineer",
    result={
        "status": "success",
        "duration": 245,
        "files_modified": ["auth.py", "config.py"],
    },
    success=True
)

# Record failure
learning.record_task_outcome(
    task="Deploy to Kubernetes",
    agent_id="devops-engineer",
    result={"error": "Helm chart validation failed"},
    success=False
)
```

### Pattern Analysis

```python
# Get learning statistics
stats = learning.get_learning_stats()
# {
#     "total_outcomes": 150,
#     "agents_tracked": 25,
#     "top_keywords": [("api", 45), ("auth", 32), ("database", 28)],
#     "agent_performance": {
#         "backend-architect": {"success": 45, "fail": 3, "rate": 0.94},
#         "devops-engineer": {"success": 38, "fail": 8, "rate": 0.83},
#     }
# }

# Get recommendations
recommendations = learning.get_recommendations("Build authentication system")
# {
#     "recommended_agent": "security-engineer",
#     "confidence": 0.87,
#     "reason": "security-engineer has 87% success rate on similar tasks",
#     "similar_tasks": [
#         {"task": "Implement OAuth2", "agent": "security-engineer", "status": "success"},
#         {"task": "Add JWT validation", "agent": "security-engineer", "status": "success"},
#     ]
# }
```

### Combined Selection (Learning + Pool)

```python
# Best of both worlds
best_agent = learning.suggest_agent_for_task(
    task="Implement rate limiting",
    pool_selector=selector
)

# Logic:
# 1. Check historical performance (confidence > 0.7 â†’ use history)
# 2. Otherwise use intelligent pool selection
# 3. Fall back to history if pool returns None
```

---

## âš ï¸ Learning System: Honest Limitations

### Current Implementation Reality

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Current Learning System Capabilities                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  âœ… What It Does:                                               â”‚
â”‚  â”œâ”€ Records success/failure outcomes (JSON file)                â”‚
â”‚  â”œâ”€ Counts keyword overlaps between tasks                       â”‚
â”‚  â”œâ”€ Calculates agent success rates (simple statistics)          â”‚
â”‚  â””â”€ Returns most common successful agent for similar keywords   â”‚
â”‚                                                                  â”‚
â”‚  âŒ What It Does NOT Do:                                        â”‚
â”‚  â”œâ”€ True machine learning or model training                     â”‚
â”‚  â”œâ”€ Semantic understanding of task similarity                   â”‚
â”‚  â”œâ”€ Contextual awareness (project type, complexity, etc.)       â”‚
â”‚  â”œâ”€ Time-weighted learning (recent vs old experiences)          â”‚
â”‚  â””â”€ Transfer learning across different domains                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Technical Debt Assessment

| Component | Current | Reality Check |
|-----------|---------|---------------|
| Similarity | Keyword overlap | Not embedding-based |
| Storage | In-memory ChromaDB | Lost on restart |
| Pattern matching | Stop-words filter | Primitive heuristic |
| Confidence score | Count / Total | Not statistically rigorous |
| Learning | None | Just statistics aggregation |

### When Current System Works Well

```python
# GOOD: Repeated similar tasks
# - Same keywords appear frequently
# - Clear agent specialization
# - Sufficient historical data (50+ outcomes)

# Example: "Build REST API" â†’ 50 past successes with backend-architect
# Result: 94% confidence, correct recommendation
```

### When Current System Fails

```python
# BAD: Novel or nuanced tasks
# - New terminology not in history
# - Cross-domain tasks
# - Context-dependent agent selection

# Example: "Optimize GraphQL resolver for real-time subscriptions"
# Result: Low confidence, possibly wrong recommendation
```

---

## ðŸš€ Evolution Path: Real ML Learning

### Phase 1: Embedding-Based Similarity (Recommended First Step)

```python
class EmbeddingLearningManager:
    """
    Upgrade from keyword matching to embedding similarity.
    Reuses existing RAG infrastructure.
    """

    def __init__(self, rag_system: RAGSystem):
        self.rag = rag_system
        self.embedding_model = rag_system.embedding_model

    def find_similar_tasks(self, task: str, limit: int = 10) -> List[Dict]:
        """
        Semantic task similarity using embeddings.

        BEFORE: keyword overlap (primitive)
        AFTER:  cosine similarity of embeddings (semantic)
        """
        task_embedding = self.embedding_model.encode(task)

        # Query experience collection with embeddings
        results = self.rag.experience_collection.query(
            query_embeddings=[task_embedding.tolist()],
            n_results=limit,
        )

        return self._process_results(results)
```

### Phase 2: Contextual Bandit (Production-Ready Learning)

```python
from vowpalwabbit import pyvw

class ContextualBanditSelector:
    """
    True online learning for agent selection.

    - Learns from feedback (success/failure)
    - Considers context (project type, complexity)
    - Balances exploration vs exploitation
    """

    def __init__(self):
        self.model = pyvw.Workspace(
            "--cb_explore_adf --epsilon 0.1 --quiet"
        )

    def select_agent(
        self,
        task: str,
        context: Dict[str, Any],
        available_agents: List[str],
    ) -> str:
        """
        Select agent using contextual bandit.

        Context features:
        - task_embedding: semantic representation
        - project_type: web, api, ml, etc.
        - complexity_score: estimated difficulty
        - time_pressure: deadline proximity
        """
        # Format for VW
        vw_example = self._format_example(task, context, available_agents)

        # Get prediction with exploration
        prediction = self.model.predict(vw_example)

        return available_agents[prediction]

    def learn(
        self,
        task: str,
        context: Dict,
        chosen_agent: str,
        reward: float,  # 1.0 for success, 0.0 for failure
    ):
        """Update model with outcome."""
        # Online learning - model improves with each interaction
        self.model.learn(self._format_with_reward(
            task, context, chosen_agent, reward
        ))
```

### Phase 3: Full Neural Learning (Advanced)

```python
class NeuralAgentSelector:
    """
    Deep learning approach for complex scenarios.

    Use when:
    - 1000+ historical outcomes
    - Complex multi-dimensional context
    - Non-linear agent-task relationships
    """

    def __init__(self):
        self.model = self._build_model()
        self.task_encoder = SentenceTransformer("all-MiniLM-L6-v2")

    def _build_model(self):
        import torch.nn as nn

        return nn.Sequential(
            nn.Linear(384 + 64, 256),  # task_emb + context
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, num_agents),  # Output: agent scores
            nn.Softmax(dim=-1),
        )
```

### Recommended Evolution Timeline

```
Phase 0 (Current): Keyword Statistics
â”œâ”€ Value: MVP, works for simple cases
â”œâ”€ Effort: Done
â””â”€ Accuracy: ~60%

Phase 1: Embedding Similarity (1-2 weeks)
â”œâ”€ Value: Major accuracy improvement
â”œâ”€ Effort: Low (reuse RAG infrastructure)
â””â”€ Accuracy: ~75%

Phase 2: Contextual Bandit (2-4 weeks)
â”œâ”€ Value: True learning, exploration
â”œâ”€ Effort: Medium (new library)
â””â”€ Accuracy: ~85%

Phase 3: Neural Network (4-8 weeks)
â”œâ”€ Value: Complex pattern recognition
â”œâ”€ Effort: High (data + training)
â””â”€ Accuracy: ~90%+
```

---

## Observability System

### Hook-Based Event Tracking

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Observability Architecture                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Agent Action â”€â”€â†’ Hook â”€â”€â†’ ObservabilityManager â”€â”€â†’ Event       â”‚
â”‚                    â”‚              â”‚                   â”‚          â”‚
â”‚                    â–¼              â–¼                   â–¼          â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚              â”‚ Create   â”‚  â”‚ AI Summary   â”‚  â”‚ Event Store â”‚    â”‚
â”‚              â”‚ Hook Fn  â”‚  â”‚ (Claude SDK) â”‚  â”‚ (JSON/DB)   â”‚    â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Components

```python
from big_three_realtime_agents.observability import ObservabilityManager

obs = ObservabilityManager()

# Send event directly
obs.send_event(
    agent_name="backend-architect",
    hook_type="agent_started",
    session_id="session_abc123",
    payload={
        "task": "Design REST API",
        "timestamp": "2024-12-07T10:30:00Z",
    },
    summary="Backend architect started API design task"
)
```

### Hook Creation

```python
# Create hook for agent lifecycle
session_holder = {"id": None}  # Updated during execution

on_agent_start = obs.create_hook(
    agent_name="backend-architect",
    hook_type="agent_started",
    session_id_holder=session_holder,
    summarize=True  # AI-powered summary generation
)

on_tool_call = obs.create_hook(
    agent_name="backend-architect",
    hook_type="tool_call",
    session_id_holder=session_holder,
    summarize=False  # Raw payload only
)

on_agent_end = obs.create_hook(
    agent_name="backend-architect",
    hook_type="agent_ended",
    session_id_holder=session_holder,
    summarize=True
)

# Use in Claude Agent SDK
from claude_agent_sdk import Agent

agent = Agent(
    name="backend-architect",
    hooks={
        "agent_started": on_agent_start,
        "tool_call": on_tool_call,
        "agent_ended": on_agent_end,
    }
)
```

### AI-Powered Summarization

```python
# Automatic event summarization using Claude
summary = await obs.generate_event_summary(
    agent_name="security-engineer",
    hook_type="tool_call",
    input_data={
        "tool_name": "Write",
        "file_path": "src/auth/middleware.py",
        "content": "class AuthMiddleware:...",
    }
)
# Returns: "Security engineer created AuthMiddleware class for
#           request authentication in src/auth/middleware.py"
```

### Supported Hook Types

| Hook Type | Trigger | Use Case |
|-----------|---------|----------|
| `agent_started` | Agent begins task | Task tracking, metrics |
| `agent_ended` | Agent completes task | Performance measurement |
| `tool_call` | Tool invocation | Debugging, audit |
| `tool_result` | Tool returns | Error tracking |
| `message_sent` | Agent sends message | Communication log |
| `error_occurred` | Exception raised | Error monitoring |

### Integration with Claude Agent SDK

```python
from claude_agent_sdk import Agent
from big_three_realtime_agents.observability import ObservabilityManager

obs = ObservabilityManager()
session = {"id": "session_" + uuid4().hex[:8]}

# Create all hooks
hooks = {
    "agent_started": obs.create_hook("my-agent", "agent_started", session, True),
    "tool_call": obs.create_hook("my-agent", "tool_call", session, False),
    "agent_ended": obs.create_hook("my-agent", "agent_ended", session, True),
}

# Agent with full observability
agent = Agent(
    name="my-agent",
    model="claude-sonnet-4-20250514",
    system_prompt="...",
    tools=[Read, Write, Edit, Bash],
    hooks=hooks,
)

# All agent actions are now tracked
result = await agent.run("Build authentication system")
```

---

## Security System

### Current Components

```python
from big_three_realtime_agents.security import (
    SecurityManager,
    AccessControl,
    AuditLogger,
    Permission,
    AuditEventType,
)

# Initialize security manager
security = SecurityManager(storage_dir="./security")

# Setup default permissions
security.initialize_default_permissions()
```

### Audit Logging (âœ… Working)

```python
# Log security events
security.audit_log(
    event_type="agent_created",
    data={
        "agent_id": "backend-architect",
        "task": "Build REST API",
        "instance_id": "inst_abc123",
    },
    user="system",
    severity="info"  # info, warning, critical
)

# Available event types
class AuditEventType(Enum):
    AGENT_CREATED = "agent_created"
    AGENT_DELETED = "agent_deleted"
    AGENT_COMMAND = "agent_command"
    TOOL_EXECUTED = "tool_executed"
    FILE_ACCESSED = "file_accessed"
    BROWSER_ACTION = "browser_action"
    AUTH_SUCCESS = "auth_success"
    AUTH_FAILURE = "auth_failure"
    SECURITY_VIOLATION = "security_violation"

# Query audit logs
recent_events = security.audit.get_recent_events(limit=100)
security_events = security.audit.search_events(
    event_type=AuditEventType.AUTH_FAILURE,
    since=datetime.now() - timedelta(hours=24)
)

# Get audit summary
summary = security.audit.get_audit_summary()
# {
#     "total_events": 1523,
#     "events_by_type": {"agent_created": 45, "tool_executed": 1200, ...},
#     "events_by_severity": {"info": 1400, "warning": 100, "critical": 23},
# }
```

### Access Control (âš ï¸ Code Exists, Not Integrated)

```python
# Permission types
class Permission(Enum):
    CREATE_AGENT = "create_agent"
    DELETE_AGENT = "delete_agent"
    COMMAND_AGENT = "command_agent"
    BROWSER_USE = "browser_use"
    FILE_READ = "file_read"
    FILE_WRITE = "file_write"
    ADMIN = "admin"

# Grant permissions
access = AccessControl()
access.grant_permission("user_123", Permission.CREATE_AGENT)
access.grant_permission("user_123", Permission.COMMAND_AGENT)

# Check permissions
if access.check_permission("user_123", Permission.CREATE_AGENT):
    # Create agent...
    pass

# Add policies
access.add_policy(
    policy_id="production_safety",
    description="Restrict dangerous operations in production",
    rules={
        "blocked_operations": ["delete_agent", "file_write"],
        "allowed_operations": ["create_agent", "command_agent", "file_read"],
    }
)
```

---

## âš ï¸ Security System: Honest Limitations

### Critical Gap: Authorization Not Integrated

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Security Integration Reality Check                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  âœ… What Actually Works:                                        â”‚
â”‚  â””â”€ Audit logging (events are recorded to JSONL files)          â”‚
â”‚                                                                  â”‚
â”‚  âš ï¸ Code Exists But NOT Used:                                   â”‚
â”‚  â”œâ”€ security.authorize() - never called in production code      â”‚
â”‚  â”œâ”€ AccessControl.check_permission() - no integration points    â”‚
â”‚  â”œâ”€ Policy enforcement - policies defined but not checked       â”‚
â”‚  â””â”€ RBAC system - permissions granted but never verified        â”‚
â”‚                                                                  â”‚
â”‚  âŒ Completely Missing:                                         â”‚
â”‚  â”œâ”€ Authentication (who is making the request?)                 â”‚
â”‚  â”œâ”€ Session management                                          â”‚
â”‚  â”œâ”€ API key / token validation                                  â”‚
â”‚  â”œâ”€ Rate limiting                                               â”‚
â”‚  â””â”€ Input sanitization                                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Current Integration (Audit Only)

```python
# orchestrator_integration.py - What's actually happening:

class OrchestratorIntegration:
    def __init__(self):
        self.security = SecurityManager(...)
        self.security.initialize_default_permissions()  # âœ… Called

    def create_pool_agent_with_learning(self, task, agent_id=None):
        # âŒ NO authorization check!
        # security.authorize(user, "create_agent") is NOT called

        result = self.pool_tools.create_pool_agent(task, agent_id)

        # âœ… Only audit logging happens
        if result.get("ok"):
            self.security.audit_log("agent_created", {...})

        return result
```

### Security Risk Assessment

| Risk | Current State | Impact |
|------|---------------|--------|
| Unauthorized agent creation | âŒ No check | Any request creates agents |
| Unauthorized file access | âŒ No check | Agents can read/write freely |
| Privilege escalation | âŒ No check | No role boundaries |
| Audit trail | âœ… Working | Events logged (post-facto only) |
| Replay attacks | âŒ No protection | No request validation |

---

## ðŸ”§ Proper Security Integration Pattern

### How It Should Work

```python
from big_three_realtime_agents.security import SecurityManager, Permission
from functools import wraps

class SecureOrchestratorIntegration:
    """
    Orchestrator with proper security integration.

    Key principle: FAIL CLOSED (deny by default)
    """

    def __init__(self):
        self.security = SecurityManager(storage_dir="./security")
        self._setup_default_policies()

    def _setup_default_policies(self):
        """Configure secure defaults."""
        # Deny-by-default policy
        self.security.access.add_policy(
            policy_id="default_deny",
            description="Deny all operations by default",
            rules={
                "blocked_operations": [],  # Block list takes precedence
                "allowed_operations": [],  # Must explicitly allow
            }
        )

        # Production safety policy
        self.security.access.add_policy(
            policy_id="production_safety",
            description="Safe operations for production",
            rules={
                "blocked_operations": ["delete_agent", "admin"],
                "allowed_operations": [
                    "create_agent", "command_agent", "file_read"
                ],
            }
        )

    def _require_auth(self, user: str, operation: str, context: dict = None):
        """
        Authorization gate - raises exception if not authorized.

        MUST be called before any privileged operation.
        """
        if not self.security.authorize(user, operation, context):
            self.security.audit_log(
                "authorization_denied",
                {"user": user, "operation": operation, "context": context},
                user=user,
                severity="warning"
            )
            raise PermissionDeniedError(
                f"User '{user}' not authorized for '{operation}'"
            )

        # Log successful authorization
        self.security.audit_log(
            "auth_success",
            {"user": user, "operation": operation},
            user=user,
            severity="info"
        )

    def create_agent(self, user: str, task: str, agent_id: str = None):
        """
        Create agent with proper authorization.
        """
        # 1. Authorization check FIRST
        self._require_auth(user, "create_agent", {"task": task})

        # 2. Only proceed if authorized
        result = self.pool_tools.create_pool_agent(task, agent_id)

        # 3. Audit successful operation
        if result.get("ok"):
            self.security.audit_log("agent_created", {
                "user": user,
                "agent_id": agent_id,
                "instance_id": result.get("instance_id"),
            }, user=user)

        return result

    def execute_tool(self, user: str, agent_id: str, tool: str, params: dict):
        """
        Execute tool with authorization and audit.
        """
        # Map tool to permission
        tool_permissions = {
            "Read": "file_read",
            "Write": "file_write",
            "Edit": "file_write",
            "Bash": "command_agent",
            "Browser": "browser_use",
        }

        operation = tool_permissions.get(tool, "command_agent")

        # Authorization check
        self._require_auth(user, operation, {
            "agent_id": agent_id,
            "tool": tool,
            "params": params,
        })

        # Execute and audit
        result = self._execute_tool_internal(agent_id, tool, params)

        self.security.audit_log("tool_executed", {
            "user": user,
            "agent_id": agent_id,
            "tool": tool,
            "success": result.get("ok", False),
        }, user=user)

        return result


class PermissionDeniedError(Exception):
    """Raised when authorization fails."""
    pass
```

### Decorator Pattern for Security

```python
def require_permission(permission: Permission):
    """
    Decorator to enforce permission check on any method.

    Usage:
        @require_permission(Permission.CREATE_AGENT)
        def create_agent(self, user: str, task: str):
            ...
    """
    def decorator(func):
        @wraps(func)
        def wrapper(self, user: str, *args, **kwargs):
            # Get security manager from self
            security = getattr(self, 'security', None)
            if not security:
                raise RuntimeError("Security manager not configured")

            # Check permission
            if not security.access.check_permission(user, permission):
                security.audit_log("auth_failure", {
                    "user": user,
                    "permission": permission.value,
                    "function": func.__name__,
                }, user=user, severity="warning")
                raise PermissionDeniedError(
                    f"Permission '{permission.value}' required"
                )

            # Proceed with authorized call
            return func(self, user, *args, **kwargs)
        return wrapper
    return decorator


# Usage
class SecureAgentPool:
    def __init__(self, security: SecurityManager):
        self.security = security

    @require_permission(Permission.CREATE_AGENT)
    def create_agent(self, user: str, task: str):
        """Only users with CREATE_AGENT permission can call this."""
        return self._create_agent_internal(task)

    @require_permission(Permission.ADMIN)
    def delete_all_agents(self, user: str):
        """Only admins can delete all agents."""
        return self._delete_all_internal()
```

### API Gateway Security Layer

```python
from fastapi import FastAPI, Depends, HTTPException, Header
from typing import Optional

app = FastAPI()
security = SecurityManager(storage_dir="./security")

async def get_current_user(
    authorization: Optional[str] = Header(None)
) -> str:
    """
    Extract and validate user from request.

    In production, implement proper JWT/OAuth validation.
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing authorization")

    # TODO: Implement proper token validation
    # For now, extract user from header
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization format")

    token = authorization[7:]
    user = validate_token(token)  # Implement this

    if not user:
        security.audit_log("auth_failure", {
            "reason": "invalid_token"
        }, severity="warning")
        raise HTTPException(status_code=401, detail="Invalid token")

    return user

async def require_permission(permission: Permission, user: str = Depends(get_current_user)):
    """FastAPI dependency for permission check."""
    if not security.access.check_permission(user, permission):
        security.audit_log("authorization_denied", {
            "user": user,
            "permission": permission.value,
        }, user=user, severity="warning")
        raise HTTPException(status_code=403, detail="Permission denied")
    return user

@app.post("/agents")
async def create_agent(
    request: CreateAgentRequest,
    user: str = Depends(lambda: require_permission(Permission.CREATE_AGENT))
):
    """Create agent - requires CREATE_AGENT permission."""
    result = orchestrator.create_agent(user, request.task)
    return result

@app.delete("/agents/{agent_id}")
async def delete_agent(
    agent_id: str,
    user: str = Depends(lambda: require_permission(Permission.DELETE_AGENT))
):
    """Delete agent - requires DELETE_AGENT permission."""
    result = orchestrator.delete_agent(user, agent_id)
    return result
```

### Security Evolution Roadmap

```
Phase 0 (Current): Audit Logging Only
â”œâ”€ Value: Post-facto analysis
â”œâ”€ Risk: No prevention
â””â”€ Action: Implement Phase 1

Phase 1: Authorization Integration (1 week)
â”œâ”€ Add _require_auth() calls to all operations
â”œâ”€ Implement decorator pattern
â”œâ”€ Configure deny-by-default policies
â””â”€ Risk reduction: ~60%

Phase 2: Authentication Layer (2 weeks)
â”œâ”€ JWT/OAuth token validation
â”œâ”€ Session management
â”œâ”€ User identity tracking
â””â”€ Risk reduction: ~80%

Phase 3: Advanced Security (4 weeks)
â”œâ”€ Rate limiting
â”œâ”€ Input sanitization
â”œâ”€ Anomaly detection
â”œâ”€ Security event correlation
â””â”€ Risk reduction: ~95%
```

---

â†’ Load L3 for custom agent implementation and production patterns
