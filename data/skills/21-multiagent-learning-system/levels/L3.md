# L3: Custom Agent Implementation & Production Patterns

## Custom Agent Creation

### ExpertDefinition Full Structure

```python
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from enum import Enum
from pathlib import Path


class AgentTier(Enum):
    """Agent quality tier."""
    TIER1 = "tier1"  # Production validated
    TIER2 = "tier2"  # Specialized/functional
    TIER3 = "tier3"  # Experimental


@dataclass
class ExpertDefinition:
    """Complete expert agent definition."""

    # Identity
    agent_id: str                      # Unique ID (e.g., "backend-architect")
    name: str                          # Display name
    tier: AgentTier                    # Quality tier
    category: str                      # Category (e.g., "architecture")

    # Matching
    description: str                   # Agent description
    triggers: List[str]                # Activation keywords
    focus_areas: List[str]             # Specialization areas

    # Configuration
    system_prompt_path: str            # Path to system prompt markdown
    allowed_tools: List[str]           # Permitted tools
    working_directory: str = "./"      # Default working directory
    max_instances: int = 3             # Max concurrent instances

    # Session config
    session_config: Dict[str, Any] = field(default_factory=lambda: {
        "model": "claude-sonnet-4-5-20250929",
        "temperature": 0.7,
        "max_turns": 10,
    })

    # Validation
    version: str = "1.0.0"
    validated: bool = False
    validation_date: Optional[str] = None
```

### Creating Custom Agent from Markdown

```python
from pathlib import Path
import yaml


def create_agent_from_markdown(md_path: str) -> ExpertDefinition:
    """
    Create ExpertDefinition from markdown file.

    Markdown format:
    ---
    name: custom-agent
    description: Custom agent description
    tier: 2
    category: custom
    triggers: [keyword1, keyword2]
    focus_areas: [area1, area2]
    tools: [Read, Write, Edit, Bash]
    ---

    ## System Prompt
    You are a custom agent...
    """
    path = Path(md_path)
    content = path.read_text(encoding="utf-8")

    # Parse YAML frontmatter
    if content.startswith("---"):
        _, frontmatter, body = content.split("---", 2)
        config = yaml.safe_load(frontmatter)
    else:
        raise ValueError("Missing YAML frontmatter")

    # Map tier
    tier_map = {1: AgentTier.TIER1, 2: AgentTier.TIER2, 3: AgentTier.TIER3}
    tier = tier_map.get(config.get("tier", 2), AgentTier.TIER2)

    return ExpertDefinition(
        agent_id=config["name"],
        name=config["name"].replace("-", " ").title(),
        tier=tier,
        category=config.get("category", "general"),
        description=config["description"],
        triggers=config.get("triggers", []),
        focus_areas=config.get("focus_areas", []),
        system_prompt_path=str(path),
        allowed_tools=config.get("tools", ["Read", "Write", "Edit"]),
    )


# Usage
custom_agent = create_agent_from_markdown("agents/my-custom-agent.md")
pool.expert_definitions[custom_agent.agent_id] = custom_agent
```

---

## Custom Agent Selector

### Extending IntelligentAgentSelector

```python
from big_three_realtime_agents.agents.pool import IntelligentAgentSelector
from typing import Dict, Optional, Callable
import re


class EnhancedAgentSelector(IntelligentAgentSelector):
    """
    Extended selector with custom scoring and learning integration.
    """

    def __init__(
        self,
        expert_definitions: Dict[str, ExpertDefinition],
        learning_manager: Optional["LearningManager"] = None,
        custom_scorers: Optional[Dict[str, Callable]] = None,
    ):
        super().__init__(expert_definitions)
        self.learning = learning_manager
        self.custom_scorers = custom_scorers or {}

    def _score_all_experts(
        self,
        task: str,
        context: Optional[str] = None
    ) -> Dict[str, float]:
        """Enhanced scoring with learning and custom scorers."""
        # Base scores from parent
        scores = super()._score_all_experts(task, context)

        # Apply learning boost
        if self.learning:
            for agent_id in scores:
                historical_rate = self._get_historical_success_rate(agent_id, task)
                scores[agent_id] += historical_rate * 2.0  # Learning weight

        # Apply custom scorers
        for scorer_name, scorer_fn in self.custom_scorers.items():
            for agent_id, expert in self.experts.items():
                custom_score = scorer_fn(task, expert, context)
                scores[agent_id] += custom_score

        return scores

    def _get_historical_success_rate(self, agent_id: str, task: str) -> float:
        """Get historical success rate from learning system."""
        if not self.learning:
            return 0.0

        recommendations = self.learning.get_recommendations(task)
        if recommendations["recommended_agent"] == agent_id:
            return recommendations["confidence"]
        return 0.0

    def register_custom_scorer(
        self,
        name: str,
        scorer: Callable[[str, ExpertDefinition, Optional[str]], float]
    ):
        """Register custom scoring function."""
        self.custom_scorers[name] = scorer


# Custom scorer example: Priority for security tasks
def security_priority_scorer(
    task: str,
    expert: ExpertDefinition,
    context: Optional[str]
) -> float:
    """Boost security-related agents for sensitive tasks."""
    security_keywords = ["auth", "security", "password", "encryption", "token"]
    task_lower = task.lower()

    if any(kw in task_lower for kw in security_keywords):
        if "security" in expert.category or "security" in expert.agent_id:
            return 5.0  # High priority boost
    return 0.0


# Usage
selector = EnhancedAgentSelector(
    expert_definitions=pool.expert_definitions,
    learning_manager=learning,
)
selector.register_custom_scorer("security_priority", security_priority_scorer)
```

---

## Advanced Workflow Execution

### DAG-Based Execution Engine

```python
from big_three_realtime_agents.workflow import (
    ExecutionEngine,
    WorkflowPlan,
    ExecutionResult,
    ExecutionStrategy,
)
from typing import List, Dict, Any
import asyncio


class AdvancedExecutionEngine:
    """
    DAG-based workflow execution with parallel processing
    and error recovery.
    """

    def __init__(
        self,
        pool_manager: "AgentPoolManager",
        memory_manager: "MemoryManager",
        learning_manager: "LearningManager",
        max_parallel: int = 3,
    ):
        self.pool = pool_manager
        self.memory = memory_manager
        self.learning = learning_manager
        self.max_parallel = max_parallel
        self.semaphore = asyncio.Semaphore(max_parallel)

    async def execute_plan(self, plan: WorkflowPlan) -> Dict[str, Any]:
        """Execute workflow plan with DAG resolution."""
        results = {}

        for stage in plan.stages:
            if stage.strategy == ExecutionStrategy.PARALLEL:
                stage_results = await self._execute_parallel(stage.tasks)
            else:
                stage_results = await self._execute_sequential(stage.tasks)

            results[stage.stage_id] = stage_results

            # Store workflow progress
            self.memory.store(
                f"workflow_{plan.plan_id}",
                {"stage": stage.stage_id, "results": stage_results},
                MemoryType.WORKFLOW
            )

        return {
            "plan_id": plan.plan_id,
            "status": "completed",
            "stages": results,
        }

    async def _execute_parallel(self, tasks: List["WorkflowTask"]) -> List[Dict]:
        """Execute tasks in parallel with semaphore control."""
        async def execute_with_limit(task):
            async with self.semaphore:
                return await self._execute_single_task(task)

        return await asyncio.gather(*[execute_with_limit(t) for t in tasks])

    async def _execute_sequential(self, tasks: List["WorkflowTask"]) -> List[Dict]:
        """Execute tasks sequentially with dependency resolution."""
        results = []
        completed = {}

        for task in tasks:
            # Wait for dependencies
            if task.dependencies:
                for dep_id in task.dependencies:
                    if dep_id not in completed:
                        raise RuntimeError(f"Dependency {dep_id} not completed")

            result = await self._execute_single_task(task)
            results.append(result)
            completed[task.task_id] = result

        return results

    async def _execute_single_task(self, task: "WorkflowTask") -> Dict[str, Any]:
        """Execute single task with learning integration."""
        # Acquire agent
        instance = await self.pool.acquire_expert(
            expert_id=task.agent_id,
            task_description=task.description,
            prefer_reuse=True
        )

        if not instance:
            return {"status": "failed", "error": "No agent available"}

        try:
            self.pool.mark_working(instance.instance_id)

            # Execute task (implementation depends on agent type)
            result = await self._run_agent_task(instance, task)

            # Record success
            self.learning.record_task_outcome(
                task=task.description,
                agent_id=task.agent_id,
                result=result,
                success=True
            )

            return {"status": "success", "result": result}

        except Exception as e:
            # Record failure
            self.learning.record_task_outcome(
                task=task.description,
                agent_id=task.agent_id,
                result={"error": str(e)},
                success=False
            )
            return {"status": "failed", "error": str(e)}

        finally:
            self.pool.release_instance(instance.instance_id)

    async def _run_agent_task(
        self,
        instance: "AgentInstance",
        task: "WorkflowTask"
    ) -> Dict[str, Any]:
        """Run task on agent instance (implementation specific)."""
        # This would integrate with Claude SDK or other execution backends
        # Placeholder for actual implementation
        return {"task_id": task.task_id, "completed": True}
```

---

## Claude Coder Integration

### Unified Coder with MCP Support

```python
from big_three_realtime_agents.agents.claude import (
    UnifiedCoder,
    AgentOptionBuilder,
    ClaudeModeSelector,
)


class ClaudeCoderIntegration:
    """
    Claude Coder with MCP server integration and
    multi-mode execution support.
    """

    def __init__(
        self,
        model: str = "claude-sonnet-4-5-20250929",
        mcp_servers: List[str] = None,
    ):
        self.model = model
        self.mcp_servers = mcp_servers or []
        self.mode_selector = ClaudeModeSelector()
        self.option_builder = AgentOptionBuilder()

    def build_agent_options(
        self,
        task: str,
        working_dir: str,
        system_prompt: str,
    ) -> Dict[str, Any]:
        """Build agent execution options."""
        # Select optimal mode
        mode = self.mode_selector.select_mode(task)

        # Build options
        options = self.option_builder.build(
            model=self.model,
            system_prompt=system_prompt,
            working_dir=working_dir,
            mode=mode,
            mcp_servers=self.mcp_servers,
            allowed_tools=["Read", "Write", "Edit", "Bash", "Grep", "Glob"],
        )

        return options

    async def execute_coding_task(
        self,
        task: str,
        working_dir: str,
        agent_prompt_path: str,
    ) -> Dict[str, Any]:
        """Execute coding task with Claude."""
        # Load system prompt
        system_prompt = Path(agent_prompt_path).read_text()

        # Build options
        options = self.build_agent_options(task, working_dir, system_prompt)

        # Execute via Claude SDK (placeholder)
        # result = await claude_sdk.run(task, **options)

        return {
            "status": "success",
            "model": self.model,
            "mode": options.get("mode"),
        }
```

---

## Gemini Browser Automation

### Playwright-Based Browser Agent

```python
from big_three_realtime_agents.agents.gemini import (
    GeminiBrowserAgent,
    BrowserActions,
    ScreenshotManager,
)
from playwright.async_api import async_playwright


class GeminiBrowserIntegration:
    """
    Gemini Browser agent with Playwright automation
    and screenshot analysis.
    """

    def __init__(self, headless: bool = True):
        self.headless = headless
        self.screenshot_manager = ScreenshotManager()
        self.browser = None
        self.page = None

    async def initialize(self):
        """Initialize browser."""
        playwright = await async_playwright().start()
        self.browser = await playwright.chromium.launch(headless=self.headless)
        self.page = await self.browser.new_page()

    async def navigate(self, url: str) -> Dict[str, Any]:
        """Navigate to URL and capture screenshot."""
        await self.page.goto(url)
        screenshot = await self.screenshot_manager.capture(self.page)

        return {
            "url": url,
            "title": await self.page.title(),
            "screenshot": screenshot,
        }

    async def execute_action(
        self,
        action: str,
        selector: str = None,
        value: str = None,
    ) -> Dict[str, Any]:
        """Execute browser action."""
        actions = BrowserActions(self.page)

        if action == "click":
            await actions.click(selector)
        elif action == "fill":
            await actions.fill(selector, value)
        elif action == "scroll":
            await actions.scroll()
        elif action == "screenshot":
            return await self.screenshot_manager.capture(self.page)

        return {"action": action, "status": "completed"}

    async def analyze_page(self, prompt: str) -> Dict[str, Any]:
        """Analyze page with Gemini vision."""
        screenshot = await self.screenshot_manager.capture(self.page)

        # Send to Gemini for analysis (placeholder)
        # analysis = await gemini.analyze_image(screenshot, prompt)

        return {
            "screenshot": screenshot,
            "analysis": "Page analysis result",
        }

    async def close(self):
        """Close browser."""
        if self.browser:
            await self.browser.close()
```

---

## Security & Audit System

### ⚠️ Current Implementation Status

```
┌─────────────────────────────────────────────────────────────────┐
│                 Security Implementation Status                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Component              │ Status    │ Integration               │
│  ──────────────────────────────────────────────────────────────│
│  SecurityManager        │ ✅ Exists │ ⚠️ Audit only            │
│  AuditLogger           │ ✅ Works  │ ✅ Fully integrated       │
│  AccessControl         │ ✅ Exists │ ❌ Not called             │
│  Permission checks     │ ✅ Code   │ ❌ Bypassed               │
│  Policy enforcement    │ ✅ Code   │ ❌ Not enforced           │
│  Authentication        │ ❌ None   │ ❌ Not implemented        │
│                                                                  │
│  VERDICT: Security is decorative, not functional               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Production-Ready Security Implementation

```python
from big_three_realtime_agents.security import (
    SecurityManager,
    AccessControl,
    AuditLogger,
    Permission,
)
from functools import wraps
from typing import List, Dict, Optional, Callable
from enum import Enum
import jwt
from datetime import datetime, timedelta


class SecureMultiAgentSystem:
    """
    Production-ready security layer for multi-agent systems.

    Implements:
    - Authentication (JWT tokens)
    - Authorization (RBAC + policies)
    - Audit logging (all operations)
    - Rate limiting
    - Input validation
    """

    def __init__(
        self,
        storage_dir: str = "./security",
        jwt_secret: str = None,
        jwt_algorithm: str = "HS256",
    ):
        self.security = SecurityManager(storage_dir=storage_dir)
        self.jwt_secret = jwt_secret or os.environ.get("JWT_SECRET")
        self.jwt_algorithm = jwt_algorithm
        self._rate_limits: Dict[str, List[datetime]] = {}

        if not self.jwt_secret:
            raise SecurityError("JWT_SECRET must be configured")

        self._setup_policies()

    def _setup_policies(self):
        """Configure default security policies."""
        # Deny-by-default
        self.security.access.add_policy(
            policy_id="default",
            description="Default deny policy",
            rules={
                "blocked_operations": [],
                "allowed_operations": [],
            }
        )

        # Standard user policy
        self.security.access.add_policy(
            policy_id="standard_user",
            description="Standard user operations",
            rules={
                "blocked_operations": ["delete_agent", "admin"],
                "allowed_operations": [
                    "create_agent",
                    "command_agent",
                    "file_read",
                ],
            }
        )

        # Admin policy
        self.security.access.add_policy(
            policy_id="admin",
            description="Administrator operations",
            rules={
                "blocked_operations": [],
                "allowed_operations": [
                    "create_agent",
                    "delete_agent",
                    "command_agent",
                    "file_read",
                    "file_write",
                    "browser_use",
                    "admin",
                ],
            }
        )

    # ─────────────────────────────────────────────────────────────
    # Authentication
    # ─────────────────────────────────────────────────────────────

    def create_token(
        self,
        user_id: str,
        role: str = "user",
        expires_hours: int = 24,
    ) -> str:
        """Create JWT authentication token."""
        payload = {
            "sub": user_id,
            "role": role,
            "iat": datetime.utcnow(),
            "exp": datetime.utcnow() + timedelta(hours=expires_hours),
        }

        token = jwt.encode(payload, self.jwt_secret, algorithm=self.jwt_algorithm)

        self.security.audit_log("token_created", {
            "user_id": user_id,
            "role": role,
            "expires_hours": expires_hours,
        }, user=user_id)

        return token

    def validate_token(self, token: str) -> Dict:
        """
        Validate JWT token and extract payload.

        Raises:
            AuthenticationError: If token is invalid or expired
        """
        try:
            payload = jwt.decode(
                token,
                self.jwt_secret,
                algorithms=[self.jwt_algorithm]
            )

            self.security.audit_log("auth_success", {
                "user_id": payload["sub"],
                "role": payload["role"],
            }, user=payload["sub"])

            return payload

        except jwt.ExpiredSignatureError:
            self.security.audit_log("auth_failure", {
                "reason": "token_expired"
            }, severity="warning")
            raise AuthenticationError("Token expired")

        except jwt.InvalidTokenError as e:
            self.security.audit_log("auth_failure", {
                "reason": "invalid_token",
                "error": str(e),
            }, severity="warning")
            raise AuthenticationError("Invalid token")

    # ─────────────────────────────────────────────────────────────
    # Authorization
    # ─────────────────────────────────────────────────────────────

    def authorize(
        self,
        user_id: str,
        operation: str,
        context: Optional[Dict] = None,
    ) -> bool:
        """
        Check if user is authorized for operation.

        This method MUST be called before any privileged operation.
        """
        # Check base permission
        has_permission = self.security.authorize(user_id, operation, context)

        if not has_permission:
            self.security.audit_log("authorization_denied", {
                "user_id": user_id,
                "operation": operation,
                "context": context,
            }, user=user_id, severity="warning")

        return has_permission

    def require_auth(
        self,
        user_id: str,
        operation: str,
        context: Optional[Dict] = None,
    ):
        """
        Authorization gate - raises if not authorized.

        Usage:
            self.require_auth(user_id, "create_agent")
            # Only reaches here if authorized
        """
        if not self.authorize(user_id, operation, context):
            raise AuthorizationError(
                f"User '{user_id}' not authorized for '{operation}'"
            )

    # ─────────────────────────────────────────────────────────────
    # Rate Limiting
    # ─────────────────────────────────────────────────────────────

    def check_rate_limit(
        self,
        user_id: str,
        limit: int = 100,
        window_seconds: int = 60,
    ) -> bool:
        """
        Check if user is within rate limit.

        Args:
            user_id: User identifier
            limit: Max requests per window
            window_seconds: Time window in seconds
        """
        now = datetime.utcnow()
        window_start = now - timedelta(seconds=window_seconds)

        # Get user's request history
        if user_id not in self._rate_limits:
            self._rate_limits[user_id] = []

        # Remove old requests outside window
        self._rate_limits[user_id] = [
            t for t in self._rate_limits[user_id]
            if t > window_start
        ]

        # Check limit
        if len(self._rate_limits[user_id]) >= limit:
            self.security.audit_log("rate_limit_exceeded", {
                "user_id": user_id,
                "limit": limit,
                "window_seconds": window_seconds,
            }, user=user_id, severity="warning")
            return False

        # Record request
        self._rate_limits[user_id].append(now)
        return True

    def require_rate_limit(
        self,
        user_id: str,
        limit: int = 100,
        window_seconds: int = 60,
    ):
        """Rate limit gate - raises if exceeded."""
        if not self.check_rate_limit(user_id, limit, window_seconds):
            raise RateLimitError(
                f"Rate limit exceeded: {limit} requests per {window_seconds}s"
            )

    # ─────────────────────────────────────────────────────────────
    # Secure Operation Wrapper
    # ─────────────────────────────────────────────────────────────

    def secure_operation(
        self,
        token: str,
        operation: str,
        func: Callable,
        *args,
        rate_limit: int = 100,
        **kwargs,
    ):
        """
        Execute operation with full security checks.

        1. Validate token (authentication)
        2. Check rate limit
        3. Verify authorization
        4. Execute operation
        5. Audit log result
        """
        # 1. Authentication
        payload = self.validate_token(token)
        user_id = payload["sub"]

        # 2. Rate limiting
        self.require_rate_limit(user_id, limit=rate_limit)

        # 3. Authorization
        self.require_auth(user_id, operation)

        # 4. Execute
        try:
            result = func(*args, **kwargs)

            # 5. Audit success
            self.security.audit_log(f"{operation}_success", {
                "user_id": user_id,
                "result_type": type(result).__name__,
            }, user=user_id)

            return result

        except Exception as e:
            # Audit failure
            self.security.audit_log(f"{operation}_failure", {
                "user_id": user_id,
                "error": str(e),
            }, user=user_id, severity="warning")
            raise


class AuthenticationError(Exception):
    """Raised when authentication fails."""
    pass


class AuthorizationError(Exception):
    """Raised when authorization fails."""
    pass


class RateLimitError(Exception):
    """Raised when rate limit is exceeded."""
    pass


class SecurityError(Exception):
    """Raised for security configuration errors."""
    pass
```

### Security Decorator for Methods

```python
def secure(
    operation: str,
    rate_limit: int = 100,
    require_admin: bool = False,
):
    """
    Decorator for secure method execution.

    Usage:
        @secure(operation="create_agent")
        def create_agent(self, token: str, task: str):
            ...
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(self, token: str, *args, **kwargs):
            security = getattr(self, 'security_system', None)
            if not security:
                raise SecurityError("Security system not configured")

            # Validate and get user
            payload = security.validate_token(token)
            user_id = payload["sub"]
            role = payload["role"]

            # Admin check
            if require_admin and role != "admin":
                security.security.audit_log("admin_required", {
                    "user_id": user_id,
                    "operation": operation,
                }, user=user_id, severity="warning")
                raise AuthorizationError("Admin role required")

            # Rate limit
            security.require_rate_limit(user_id, limit=rate_limit)

            # Authorization
            security.require_auth(user_id, operation)

            # Execute with user context
            return func(self, token, user_id=user_id, *args, **kwargs)

        return wrapper
    return decorator


# Usage example
class SecureAgentOrchestrator:
    def __init__(self):
        self.security_system = SecureMultiAgentSystem()
        self.pool = AgentPoolManager()

    @secure(operation="create_agent", rate_limit=50)
    def create_agent(self, token: str, task: str, user_id: str = None):
        """Create agent - requires authentication and create_agent permission."""
        instance = self.pool.acquire_expert(
            expert_id=self._select_agent(task),
            task_description=task,
        )
        return {"instance_id": instance.instance_id, "created_by": user_id}

    @secure(operation="delete_agent", require_admin=True)
    def delete_agent(self, token: str, agent_id: str, user_id: str = None):
        """Delete agent - requires admin role."""
        self.pool.terminate_instance(agent_id)
        return {"deleted": agent_id, "deleted_by": user_id}
```

### Input Validation & Sanitization

```python
import re
from typing import Any
from pydantic import BaseModel, validator, Field


class SecureTaskRequest(BaseModel):
    """Validated task request with security constraints."""

    task: str = Field(..., min_length=1, max_length=10000)
    agent_id: Optional[str] = Field(None, regex=r'^[a-z0-9\-]+$')
    context: Optional[Dict[str, Any]] = None

    @validator('task')
    def sanitize_task(cls, v):
        """Remove potentially dangerous patterns from task."""
        # Remove shell injection patterns
        dangerous_patterns = [
            r'\$\(.*\)',      # $(command)
            r'`.*`',          # `command`
            r'\|',            # pipe
            r';',             # command separator
            r'&&',            # command chain
            r'\|\|',          # command chain
            r'>\s*/dev/',     # device redirect
        ]

        for pattern in dangerous_patterns:
            if re.search(pattern, v):
                raise ValueError(f"Task contains prohibited pattern")

        return v

    @validator('context')
    def validate_context(cls, v):
        """Limit context depth and size."""
        if v is None:
            return v

        # Check depth
        def check_depth(obj, depth=0, max_depth=5):
            if depth > max_depth:
                raise ValueError("Context too deeply nested")
            if isinstance(obj, dict):
                for val in obj.values():
                    check_depth(val, depth + 1)
            elif isinstance(obj, list):
                for item in obj:
                    check_depth(item, depth + 1)

        check_depth(v)
        return v


def validate_file_path(path: str, allowed_dirs: List[str]) -> str:
    """
    Validate file path is within allowed directories.

    Prevents path traversal attacks.
    """
    import os

    # Resolve to absolute path
    abs_path = os.path.abspath(path)

    # Check against allowed directories
    for allowed in allowed_dirs:
        allowed_abs = os.path.abspath(allowed)
        if abs_path.startswith(allowed_abs):
            return abs_path

    raise SecurityError(f"Path '{path}' is outside allowed directories")
```

---

## Production Deployment Patterns

### Multi-Agent Orchestration Service

```python
import asyncio
from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel


app = FastAPI(title="Multi-Agent Orchestration Service")


class TaskRequest(BaseModel):
    task: str
    context: str = ""
    preferred_agent: str = None


class OrchestratorService:
    """Production orchestration service."""

    def __init__(self):
        self.pool = AgentPoolManager()
        self.memory = MemoryManager(storage_dir="./production/memory")
        self.learning = LearningManager(storage_dir="./production/learning")
        self.selector = EnhancedAgentSelector(
            self.pool.expert_definitions,
            self.learning
        )
        self.security = EnterpriseSecurityManager()
        self.engine = AdvancedExecutionEngine(
            self.pool, self.memory, self.learning
        )

    async def process_task(self, request: TaskRequest) -> Dict[str, Any]:
        """Process incoming task request."""
        # Select best agent
        if request.preferred_agent:
            agent_id = request.preferred_agent
        else:
            agent_id = self.selector.select_best_agent(
                request.task,
                request.context
            )

        # Check permissions
        if not self.security.check_permission(agent_id, "execute", Permission.EXECUTE):
            return {"error": "Permission denied"}

        # Create simple plan
        planner = WorkflowPlanner(self.pool, self.memory)
        plan = planner.create_simple_plan(request.task, agent_id)

        # Execute
        result = await self.engine.execute_plan(plan)

        return {
            "task": request.task,
            "agent": agent_id,
            "result": result,
        }


orchestrator = OrchestratorService()


@app.post("/tasks")
async def create_task(request: TaskRequest, background_tasks: BackgroundTasks):
    """Create and execute task."""
    result = await orchestrator.process_task(request)
    return result


@app.get("/agents")
async def list_agents():
    """List available agents."""
    return orchestrator.pool.list_expert_types()


@app.get("/stats")
async def get_stats():
    """Get system statistics."""
    return {
        "pool": orchestrator.pool.get_stats(),
        "memory": orchestrator.memory.get_stats(),
        "learning": orchestrator.learning.get_learning_stats(),
    }
```

---

## Circuit Breaker Pattern

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                   Circuit Breaker State Machine                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ┌─────────┐                                                  │
│    │ CLOSED  │ ◄────────────────────────────────────────┐       │
│    │(normal) │                                          │       │
│    └────┬────┘                                          │       │
│         │ failures >= threshold                         │       │
│         ▼                                          success      │
│    ┌─────────┐   recovery_timeout   ┌───────────┐    │       │
│    │  OPEN   │ ─────────────────► │ HALF_OPEN │ ────┘       │
│    │(blocked)│                      │ (testing) │            │
│    └────┬────┘                      └─────┬─────┘            │
│         │                                 │ failure          │
│         └─────────────────────────────────┘                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Core Implementation

```python
from big_three_realtime_agents.utils.circuit_breaker import (
    CircuitBreaker,
    CircuitState,
    circuit_breaker,  # Decorator
    get_circuit_breaker,  # Singleton factory
)
from enum import Enum
from typing import Callable, Any


class CircuitState(Enum):
    """Circuit breaker states (Martin Fowler pattern)."""
    CLOSED = "closed"      # Normal operation, calls pass through
    OPEN = "open"          # Failures detected, calls blocked
    HALF_OPEN = "half_open"  # Testing recovery, limited calls


class CircuitBreaker:
    """
    Circuit Breaker for fault tolerance and cascading failure prevention.

    Based on Martin Fowler's Circuit Breaker pattern:
    https://martinfowler.com/bliki/CircuitBreaker.html
    """

    def __init__(
        self,
        failure_threshold: int = 5,
        recovery_timeout: float = 30.0,
        half_open_max_calls: int = 3,
    ):
        """
        Args:
            failure_threshold: Number of failures before opening circuit
            recovery_timeout: Seconds to wait before testing recovery
            half_open_max_calls: Max calls allowed in half-open state
        """
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.half_open_max_calls = half_open_max_calls

        self._state = CircuitState.CLOSED
        self._failure_count = 0
        self._success_count = 0
        self._last_failure_time = None
        self._half_open_calls = 0

    @property
    def state(self) -> CircuitState:
        """Get current circuit state with automatic transition check."""
        self._check_state_transition()
        return self._state

    def _check_state_transition(self):
        """Check and perform automatic state transitions."""
        if self._state == CircuitState.OPEN:
            if self._should_attempt_reset():
                self._state = CircuitState.HALF_OPEN
                self._half_open_calls = 0

    def _should_attempt_reset(self) -> bool:
        """Check if recovery timeout has passed."""
        if self._last_failure_time is None:
            return False
        elapsed = time.time() - self._last_failure_time
        return elapsed >= self.recovery_timeout

    def can_execute(self) -> bool:
        """Check if calls are allowed."""
        state = self.state

        if state == CircuitState.CLOSED:
            return True
        elif state == CircuitState.OPEN:
            return False
        else:  # HALF_OPEN
            return self._half_open_calls < self.half_open_max_calls

    def record_success(self):
        """Record successful call."""
        if self._state == CircuitState.HALF_OPEN:
            self._success_count += 1
            if self._success_count >= self.half_open_max_calls:
                # Recovery successful, close circuit
                self._state = CircuitState.CLOSED
                self._reset_counts()
        else:
            self._failure_count = 0  # Reset on success in closed state

    def record_failure(self):
        """Record failed call."""
        self._failure_count += 1
        self._last_failure_time = time.time()

        if self._state == CircuitState.CLOSED:
            if self._failure_count >= self.failure_threshold:
                self._state = CircuitState.OPEN
        elif self._state == CircuitState.HALF_OPEN:
            # Failure during recovery, reopen circuit
            self._state = CircuitState.OPEN
            self._half_open_calls = 0

    def _reset_counts(self):
        """Reset all counters."""
        self._failure_count = 0
        self._success_count = 0
        self._half_open_calls = 0

    def call(self, func: Callable, *args, **kwargs) -> Any:
        """
        Execute function with circuit breaker protection.

        Usage:
            cb = CircuitBreaker()
            result = cb.call(risky_function, arg1, arg2)
        """
        if not self.can_execute():
            raise CircuitOpenError(
                f"Circuit is {self.state.value}, "
                f"call blocked for {self.recovery_timeout}s"
            )

        if self._state == CircuitState.HALF_OPEN:
            self._half_open_calls += 1

        try:
            result = func(*args, **kwargs)
            self.record_success()
            return result
        except Exception as e:
            self.record_failure()
            raise

    def get_stats(self) -> dict:
        """Get circuit breaker statistics."""
        return {
            "state": self.state.value,
            "failure_count": self._failure_count,
            "failure_threshold": self.failure_threshold,
            "recovery_timeout": self.recovery_timeout,
            "last_failure_time": self._last_failure_time,
        }


class CircuitOpenError(Exception):
    """Raised when circuit is open and call is blocked."""
    pass
```

### Decorator Pattern

```python
from functools import wraps

def circuit_breaker(
    failure_threshold: int = 5,
    recovery_timeout: float = 30.0,
    name: str = "default",
) -> Callable:
    """
    Decorator to apply circuit breaker to any function.

    Usage:
        @circuit_breaker(failure_threshold=3, recovery_timeout=60)
        async def call_external_api():
            return await api.request()
    """
    def decorator(func: Callable) -> Callable:
        cb = get_circuit_breaker(
            name=name,
            failure_threshold=failure_threshold,
            recovery_timeout=recovery_timeout,
        )

        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            return cb.call(func, *args, **kwargs)

        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            if not cb.can_execute():
                raise CircuitOpenError(f"Circuit {name} is open")
            try:
                result = await func(*args, **kwargs)
                cb.record_success()
                return result
            except Exception:
                cb.record_failure()
                raise

        # Return appropriate wrapper based on function type
        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        return sync_wrapper

    return decorator


# Usage examples
@circuit_breaker(failure_threshold=3, recovery_timeout=60, name="openai_api")
async def call_openai(prompt: str):
    """OpenAI API call with circuit breaker protection."""
    return await openai.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )

@circuit_breaker(failure_threshold=5, recovery_timeout=30, name="database")
def query_database(sql: str):
    """Database query with circuit breaker protection."""
    return db.execute(sql)
```

### Singleton Factory

```python
# Global circuit breaker registry
_circuit_breakers: Dict[str, CircuitBreaker] = {}


def get_circuit_breaker(
    name: str,
    failure_threshold: int = 5,
    recovery_timeout: float = 30.0,
    half_open_max_calls: int = 3,
) -> CircuitBreaker:
    """
    Get or create a named circuit breaker (singleton pattern).

    Ensures same circuit breaker instance is used across application
    for consistent state management.

    Usage:
        # First call creates the circuit breaker
        cb = get_circuit_breaker("api", failure_threshold=3)

        # Subsequent calls return same instance
        cb2 = get_circuit_breaker("api")
        assert cb is cb2  # Same instance
    """
    if name not in _circuit_breakers:
        _circuit_breakers[name] = CircuitBreaker(
            failure_threshold=failure_threshold,
            recovery_timeout=recovery_timeout,
            half_open_max_calls=half_open_max_calls,
        )
    return _circuit_breakers[name]


def reset_circuit_breaker(name: str):
    """Reset circuit breaker to initial state."""
    if name in _circuit_breakers:
        cb = _circuit_breakers[name]
        cb._state = CircuitState.CLOSED
        cb._reset_counts()


def get_all_circuit_stats() -> Dict[str, dict]:
    """Get stats for all circuit breakers."""
    return {
        name: cb.get_stats()
        for name, cb in _circuit_breakers.items()
    }
```

### Integration with Agent Pool

```python
from big_three_realtime_agents.agents.pool import AgentPoolManager
from big_three_realtime_agents.utils.circuit_breaker import (
    CircuitBreaker,
    CircuitOpenError,
    get_circuit_breaker,
)


class ResilientAgentPool:
    """Agent pool with circuit breaker protection for each agent type."""

    def __init__(self, pool: AgentPoolManager):
        self.pool = pool
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}

    def _get_agent_circuit(self, agent_id: str) -> CircuitBreaker:
        """Get circuit breaker for specific agent type."""
        return get_circuit_breaker(
            name=f"agent_{agent_id}",
            failure_threshold=3,
            recovery_timeout=60,
        )

    async def acquire_with_resilience(
        self,
        expert_id: str,
        task_description: str,
    ) -> Optional["AgentInstance"]:
        """Acquire agent with circuit breaker protection."""
        cb = self._get_agent_circuit(expert_id)

        if not cb.can_execute():
            # Try fallback agent
            fallback = self._get_fallback_agent(expert_id)
            if fallback:
                return await self.acquire_with_resilience(
                    fallback, task_description
                )
            raise CircuitOpenError(
                f"Agent {expert_id} circuit open, no fallback available"
            )

        try:
            instance = await self.pool.acquire_expert(
                expert_id=expert_id,
                task_description=task_description,
            )
            cb.record_success()
            return instance
        except Exception as e:
            cb.record_failure()
            raise

    def _get_fallback_agent(self, agent_id: str) -> Optional[str]:
        """Get fallback agent for failed agent type."""
        fallbacks = {
            "backend-architect": "fullstack-developer",
            "frontend-developer": "fullstack-developer",
            "security-engineer": "backend-architect",
        }
        return fallbacks.get(agent_id)

    def get_pool_health(self) -> Dict[str, Any]:
        """Get health status of all agent circuits."""
        return {
            agent_id: get_circuit_breaker(f"agent_{agent_id}").get_stats()
            for agent_id in self.pool.expert_definitions.keys()
        }
```

---

### Health Monitoring

```python
from big_three_realtime_agents.utils import CircuitBreaker, retry


class HealthMonitor:
    """System health monitoring."""

    def __init__(self, orchestrator: OrchestratorService):
        self.orchestrator = orchestrator
        self.circuit_breaker = CircuitBreaker(
            failure_threshold=5,
            recovery_timeout=60
        )

    async def health_check(self) -> Dict[str, Any]:
        """Comprehensive health check."""
        return {
            "status": "healthy",
            "pool": {
                "total_agents": len(self.orchestrator.pool.expert_definitions),
                "active_instances": len(self.orchestrator.pool.active_instances),
            },
            "memory": self.orchestrator.memory.get_stats(),
            "learning": {
                "outcomes_tracked": len(self.orchestrator.learning.tracker._outcomes)
            },
            "circuit_breaker": self.circuit_breaker.state,
        }

    @retry(max_attempts=3, delay=1.0)
    async def execute_with_resilience(self, task: TaskRequest) -> Dict:
        """Execute with circuit breaker and retry."""
        if not self.circuit_breaker.can_execute():
            return {"error": "Service temporarily unavailable"}

        try:
            result = await self.orchestrator.process_task(task)
            self.circuit_breaker.record_success()
            return result
        except Exception as e:
            self.circuit_breaker.record_failure()
            raise
```

---

## Security System (Production-Ready)

### Current Implementation Status

```
┌─────────────────────────────────────────────────────────────────┐
│                    Security Layer Status                         │
├─────────────────────────────────────────────────────────────────┤
│  Component          │ Code Exists │ Actually Integrated         │
├─────────────────────────────────────────────────────────────────┤
│  Audit Logging      │     ✅      │     ✅ Works               │
│  RBAC System        │     ✅      │     ❌ Never called        │
│  Policy Engine      │     ✅      │     ❌ Never called        │
│  Token Auth         │     ❌      │     ❌ Not implemented     │
│  Rate Limiting      │     ❌      │     ❌ Not implemented     │
└─────────────────────────────────────────────────────────────────┘

⚠️ CRITICAL: security.authorize() exists but is NEVER called in production!
Only audit logging is functional.
```

### Production-Ready Security Implementation

```python
"""
SecureMultiAgentSystem - Full security layer implementation.

This class provides what the current system lacks:
- JWT authentication
- RBAC authorization (actually enforced)
- Rate limiting
- Input validation
"""
import hashlib
import hmac
import json
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any, Callable, Dict, List, Optional
from functools import wraps


class SecurityLevel(Enum):
    PUBLIC = "public"
    AUTHENTICATED = "authenticated"
    PRIVILEGED = "privileged"
    ADMIN = "admin"


@dataclass
class SecurityContext:
    user_id: str
    role: str
    permissions: List[str]
    session_id: str
    authenticated_at: float


class SecureMultiAgentSystem:
    """Production-ready security layer for multi-agent systems."""

    def __init__(self, secret_key: str, audit_logger: "AuditLogger"):
        self.secret_key = secret_key
        self.audit = audit_logger
        self._rate_limits: Dict[str, List[float]] = {}
        self._revoked_tokens: set = set()

        # Role-based permissions (RBAC)
        self.role_permissions = {
            "admin": ["*"],  # All permissions
            "developer": [
                "agent:execute", "agent:list", "workflow:create",
                "workflow:execute", "memory:read", "memory:write"
            ],
            "operator": [
                "agent:execute", "agent:list", "workflow:execute",
                "memory:read"
            ],
            "viewer": ["agent:list", "workflow:list", "memory:read"],
        }

    # ==================== Authentication ====================

    def create_token(
        self,
        user_id: str,
        role: str = "viewer",
        expires_hours: int = 24
    ) -> str:
        """Create JWT-like token with HMAC signature."""
        payload = {
            "user_id": user_id,
            "role": role,
            "iat": time.time(),
            "exp": time.time() + (expires_hours * 3600),
        }
        payload_b64 = self._base64_encode(json.dumps(payload))
        signature = self._sign(payload_b64)
        return f"{payload_b64}.{signature}"

    def validate_token(self, token: str) -> Optional[Dict]:
        """Validate token and return payload if valid."""
        if token in self._revoked_tokens:
            return None

        try:
            payload_b64, signature = token.rsplit(".", 1)

            # Verify signature
            if not hmac.compare_digest(signature, self._sign(payload_b64)):
                self.audit.log_security_event(
                    "invalid_signature",
                    {"token_prefix": token[:20]}
                )
                return None

            payload = json.loads(self._base64_decode(payload_b64))

            # Check expiration
            if payload.get("exp", 0) < time.time():
                self.audit.log_security_event(
                    "token_expired",
                    {"user_id": payload.get("user_id")}
                )
                return None

            return payload

        except Exception as e:
            self.audit.log_security_event("token_validation_error", {"error": str(e)})
            return None

    def revoke_token(self, token: str):
        """Revoke a token (for logout/security)."""
        self._revoked_tokens.add(token)
        self.audit.log_security_event("token_revoked", {"token_prefix": token[:20]})

    # ==================== Authorization ====================

    def authorize(
        self,
        user_id: str,
        operation: str,
        context: Optional[Dict] = None
    ) -> bool:
        """
        Check if user is authorized for operation.

        IMPORTANT: This must be called before every sensitive operation!
        The current system has this method but NEVER calls it.
        """
        # Get user's role and permissions
        user_role = self._get_user_role(user_id)
        permissions = self.role_permissions.get(user_role, [])

        # Check permission
        authorized = "*" in permissions or operation in permissions

        # Audit log (always)
        self.audit.log_access(
            user_id=user_id,
            operation=operation,
            authorized=authorized,
            context=context or {}
        )

        return authorized

    def require_auth(
        self,
        user_id: str,
        operation: str,
        context: Optional[Dict] = None
    ):
        """Raise exception if not authorized (fail-closed)."""
        if not self.authorize(user_id, operation, context):
            raise PermissionError(
                f"User {user_id} not authorized for {operation}"
            )

    # ==================== Rate Limiting ====================

    def check_rate_limit(
        self,
        user_id: str,
        limit: int = 100,
        window_seconds: int = 60
    ) -> bool:
        """Check if user is within rate limit."""
        now = time.time()
        window_start = now - window_seconds

        # Get user's request timestamps
        if user_id not in self._rate_limits:
            self._rate_limits[user_id] = []

        # Clean old entries
        self._rate_limits[user_id] = [
            ts for ts in self._rate_limits[user_id]
            if ts > window_start
        ]

        # Check limit
        if len(self._rate_limits[user_id]) >= limit:
            self.audit.log_security_event(
                "rate_limit_exceeded",
                {"user_id": user_id, "limit": limit, "window": window_seconds}
            )
            return False

        # Record this request
        self._rate_limits[user_id].append(now)
        return True

    # ==================== Secure Operation Wrapper ====================

    def secure_operation(
        self,
        token: str,
        operation: str,
        func: Callable,
        *args,
        rate_limit: int = 100,
        **kwargs
    ) -> Any:
        """
        Execute function with full security checks.

        This is the CORRECT way to integrate security:
        1. Validate token
        2. Check authorization
        3. Check rate limit
        4. Execute operation
        5. Audit result
        """
        # 1. Validate token
        payload = self.validate_token(token)
        if not payload:
            raise PermissionError("Invalid or expired token")

        user_id = payload["user_id"]

        # 2. Check rate limit
        if not self.check_rate_limit(user_id, limit=rate_limit):
            raise RateLimitError(f"Rate limit exceeded for {user_id}")

        # 3. Check authorization
        self.require_auth(user_id, operation)

        # 4. Execute with audit
        start_time = time.time()
        try:
            result = func(*args, **kwargs)

            # 5. Audit success
            self.audit.log_operation(
                user_id=user_id,
                operation=operation,
                success=True,
                duration=time.time() - start_time
            )

            return result

        except Exception as e:
            # Audit failure
            self.audit.log_operation(
                user_id=user_id,
                operation=operation,
                success=False,
                error=str(e),
                duration=time.time() - start_time
            )
            raise

    # ==================== Helper Methods ====================

    def _sign(self, data: str) -> str:
        """Create HMAC signature."""
        return hmac.new(
            self.secret_key.encode(),
            data.encode(),
            hashlib.sha256
        ).hexdigest()

    def _base64_encode(self, data: str) -> str:
        import base64
        return base64.urlsafe_b64encode(data.encode()).decode()

    def _base64_decode(self, data: str) -> str:
        import base64
        return base64.urlsafe_b64decode(data.encode()).decode()

    def _get_user_role(self, user_id: str) -> str:
        """Get user's role (implement with your user store)."""
        # In production: query database
        # For now: default to viewer
        return "viewer"


class RateLimitError(Exception):
    """Raised when rate limit is exceeded."""
    pass
```

### Security Decorator Pattern

```python
def secure(operation: str, rate_limit: int = 100):
    """
    Decorator for securing functions with authentication and authorization.

    Usage:
        @secure("agent:execute", rate_limit=50)
        async def execute_agent(token: str, agent_id: str, task: str):
            # Token validation, auth check, rate limit all happen automatically
            return await pool.execute(agent_id, task)
    """
    def decorator(func: Callable):
        @wraps(func)
        async def wrapper(token: str, *args, **kwargs):
            security = get_security_manager()  # Singleton

            # Full security check
            payload = security.validate_token(token)
            if not payload:
                raise PermissionError("Invalid token")

            user_id = payload["user_id"]

            if not security.check_rate_limit(user_id, limit=rate_limit):
                raise RateLimitError("Rate limit exceeded")

            security.require_auth(user_id, operation)

            # Execute
            return await func(token, *args, **kwargs)

        return wrapper
    return decorator


# Usage example
@secure("agent:execute", rate_limit=50)
async def execute_agent_task(token: str, agent_id: str, task: str):
    """Execute agent task with full security."""
    pool = AgentPoolManager()
    instance = await pool.acquire_expert(agent_id, task)
    return await instance.execute(task)
```

### Input Validation & Sanitization

```python
from pydantic import BaseModel, Field, validator
import re


class SecureTaskRequest(BaseModel):
    """Validated task request with security constraints."""

    task: str = Field(..., min_length=1, max_length=10000)
    agent_id: str = Field(..., pattern=r"^[a-z][a-z0-9-]{2,49}$")
    priority: int = Field(default=5, ge=1, le=10)
    timeout: int = Field(default=300, ge=10, le=3600)

    @validator("task")
    def sanitize_task(cls, v):
        """Remove potential injection patterns."""
        # Remove script tags
        v = re.sub(r"<script[^>]*>.*?</script>", "", v, flags=re.IGNORECASE | re.DOTALL)
        # Remove SQL injection patterns
        v = re.sub(r"(;|\s)(DROP|DELETE|UPDATE|INSERT)\s", " ", v, flags=re.IGNORECASE)
        return v.strip()

    @validator("agent_id")
    def validate_agent_id(cls, v):
        """Ensure agent_id exists in pool."""
        allowed_agents = get_allowed_agent_ids()  # From pool
        if v not in allowed_agents:
            raise ValueError(f"Unknown agent: {v}")
        return v


def validate_file_path(path: str, allowed_dirs: List[str]) -> bool:
    """Validate file path to prevent directory traversal."""
    import os

    # Normalize path
    normalized = os.path.normpath(path)

    # Check for traversal attempts
    if ".." in normalized:
        return False

    # Check if within allowed directories
    abs_path = os.path.abspath(normalized)
    return any(
        abs_path.startswith(os.path.abspath(d))
        for d in allowed_dirs
    )
```

### Integration Example

```python
"""
Complete secure orchestrator integration.
Shows how security SHOULD be integrated (vs current implementation).
"""

class SecureOrchestrator:
    """Orchestrator with proper security integration."""

    def __init__(self):
        self.pool = AgentPoolManager()
        self.memory = MemoryManager()
        self.learning = LearningManager()
        self.security = SecureMultiAgentSystem(
            secret_key=os.environ["SECRET_KEY"],
            audit_logger=AuditLogger()
        )

    async def process_task(
        self,
        token: str,
        request: SecureTaskRequest
    ) -> Dict[str, Any]:
        """
        Process task with ACTUAL security enforcement.

        Current system: security.audit() only
        This implementation: validate → authorize → rate limit → execute
        """
        # 1. Validate token
        payload = self.security.validate_token(token)
        if not payload:
            raise PermissionError("Authentication required")

        user_id = payload["user_id"]

        # 2. Rate limit check
        if not self.security.check_rate_limit(user_id, limit=100):
            raise RateLimitError("Too many requests")

        # 3. Authorization check (THIS IS WHAT'S MISSING!)
        self.security.require_auth(
            user_id=user_id,
            operation="agent:execute",
            context={"agent_id": request.agent_id}
        )

        # 4. Execute task
        agent = await self.pool.acquire_expert(
            expert_id=request.agent_id,
            task_description=request.task
        )

        try:
            result = await agent.execute(request.task)

            # 5. Record learning outcome
            self.learning.record_task_outcome(
                task=request.task,
                agent_id=request.agent_id,
                result=result,
                success=True
            )

            return {"status": "success", "result": result}

        finally:
            self.pool.release_instance(agent.instance_id)
```

---

## Agent Validation (8-Step Process)

```yaml
Tier 1 Validation Process:
  1_syntax_check:
    - Valid YAML frontmatter
    - Required fields present
    - Proper markdown structure

  2_trigger_quality:
    - 5+ unique triggers
    - No overlap with existing agents
    - Domain-appropriate keywords

  3_prompt_review:
    - Clear role definition
    - Specific guidelines
    - Tool usage instructions

  4_tool_validation:
    - Only allowed tools listed
    - Tool combinations sensible
    - No dangerous tool access

  5_functional_test:
    - 10+ test tasks executed
    - Success rate > 80%
    - Response quality acceptable

  6_integration_test:
    - Works with pool manager
    - Learning integration verified
    - Memory system compatible

  7_performance_test:
    - Response time < 30s average
    - Token usage reasonable
    - No memory leaks

  8_security_review:
    - No prompt injection vulnerabilities
    - Permissions properly scoped
    - Audit trail complete
```

---

## Directory Structure

```
multiagent-system/
├── apps/realtime_poc/
│   └── big_three_realtime_agents/
│       ├── agents/
│       │   ├── claude/          # Claude Coder integration
│       │   ├── gemini/          # Gemini Browser automation
│       │   ├── openai/          # OpenAI Orchestrator
│       │   └── pool/            # Agent pool management
│       ├── learning/            # Learning system
│       │   ├── learning_manager.py
│       │   ├── outcome_tracker.py
│       │   └── pattern_analyzer.py
│       ├── memory/              # Memory system
│       │   ├── memory_manager.py
│       │   ├── session_memory.py
│       │   ├── workflow_memory.py
│       │   └── context_store.py
│       ├── workflow/            # Workflow execution
│       │   ├── workflow_planner.py
│       │   ├── execution_engine.py
│       │   └── workflow_models.py
│       ├── security/            # Security & audit
│       │   ├── security_manager.py
│       │   ├── access_control.py
│       │   └── audit_logger.py
│       └── utils/               # Utilities
│           ├── circuit_breaker.py
│           └── retry.py
├── agentpool/                   # Agent definitions
│   ├── tier1-core/              # 20 production agents
│   ├── tier2-specialized/       # ~100 specialized agents
│   └── tier3-experimental/      # ~40 experimental agents
└── memory_store/                # Persistent storage
    ├── workflows/
    ├── context/
    └── learning/
```

---

## 실용적 충돌 해결 가이드

> **핵심**: Claude Code에서 "충돌 해결"은 오케스트레이터(메인 Claude)가
> 여러 에이전트의 결과를 비교하고 판단하는 것입니다.
> 자동화된 시스템이 아닌, 오케스트레이터의 판단 가이드라인입니다.

### 충돌 상황 인식

```markdown
## 충돌 발생 조건

여러 에이전트가 다른 의견을 제시했을 때:
- Agent A: "방법 X가 좋습니다"
- Agent B: "방법 Y가 좋습니다"

## 오케스트레이터가 확인할 사항
1. 두 의견이 실제로 상충하는가? (단순히 다른 관점일 수도)
2. 어떤 도메인에 대한 충돌인가? (보안, 성능, 설계 등)
3. 각 의견의 근거는 무엇인가?
```

### 우선순위 기반 판단

```markdown
## 도메인별 우선순위 (오케스트레이터 참고용)

보안 관련 충돌 시:
  → security-engineer 의견 우선

설계 관련 충돌 시:
  → architect 의견 우선 (backend/system/frontend)

성능 관련 충돌 시:
  → performance-engineer 의견 우선

구현 세부사항 충돌 시:
  → 해당 도메인 전문가 의견 우선

## 예시 판단

"보안 vs 사용 편의성" 충돌:
  → 보안 우선 (security-engineer)

"코드 구조 vs 성능 최적화" 충돌:
  → 프로젝트 맥락에 따라 판단
  → 대부분: 구조 우선, 측정된 병목에서만 최적화
```

### 근거 기반 판단

```markdown
## 에이전트에게 요청할 때

각 에이전트에게 근거 요청:
"의견을 제시할 때 다음을 포함하세요:
- 왜 이 방법을 권장하는가?
- 대안은 무엇이고 왜 선택하지 않았는가?
- 이 방법의 트레이드오프는?"

## 오케스트레이터 판단 기준

1. 근거의 구체성
   - 구체적 기술적 이유 > 일반적 원칙

2. 프로젝트 맥락 적합성
   - 현재 프로젝트에 더 맞는 쪽

3. 리스크 평가
   - 잘못될 경우 영향이 적은 쪽
```

### 제3 의견 요청

```markdown
## 충돌 해결이 어려울 때

Step 1: 충돌 정리
"Agent A와 Agent B의 의견이 다릅니다:
- A: [의견 및 근거]
- B: [의견 및 근거]"

Step 2: 제3 에이전트에게 검토 요청
[Task: system-architect]
"두 의견을 검토하고 어떤 것이 더 적합한지 판단해주세요:
- 의견 A: [내용]
- 의견 B: [내용]
- 프로젝트 맥락: [설명]"

Step 3: 종합 판단
오케스트레이터가 제3 의견을 참고하여 최종 결정
```

### 사용자 에스컬레이션

```markdown
## 기술적으로 판단하기 어려운 경우

비즈니스 영향이 큰 결정:
→ 사용자에게 선택지 제시

[AskUserQuestion]
"두 가지 접근 방식이 있습니다:

A: [설명]
- 장점: ...
- 단점: ...

B: [설명]
- 장점: ...
- 단점: ...

어떤 방향을 선호하시나요?"
```

---

## 실용적 효율성 가이드

> **핵심**: Claude Code에는 자동 로드 밸런싱이 없습니다.
> 오케스트레이터가 효율적으로 에이전트를 활용하는 가이드라인입니다.

### 병렬화 최대화

```markdown
## 원칙
독립적인 작업은 항상 병렬로 실행

## 예시: 코드 리뷰
한 메시지에서 병렬 호출:
[Task: backend-architect] "구조 검토"
[Task: security-engineer] "보안 검토"
[Task: quality-engineer] "품질 검토"

→ 3개 동시 실행 = 시간 1/3
```

### 적절한 모델 선택

```markdown
## 작업별 모델 권장

복잡한 설계 결정:
  → model="opus"

일반 분석/구현:
  → model="sonnet" (기본)

단순 탐색/검증:
  → model="haiku"
```

### Task vs 직접 실행

```markdown
## 판단 기준

직접 실행 (빠름, 저렴):
- 파일 읽기 → Read
- 패턴 검색 → Grep
- 시스템 명령 → Bash

Task 사용 (전문 지식 필요):
- 복잡한 분석
- 아키텍처 설계
- 보안 검토
```

### 재시도 전략

```markdown
## 에이전트 결과 불충분 시

1차: 피드백과 함께 동일 에이전트에 재요청
"이전 결과가 {부족한 점}. {구체적 개선 요청}"

2차: 다른 전문 에이전트 시도

3차: 작업을 작은 단위로 분할하여 재시도

최종: 오케스트레이터가 직접 처리
```

---

## Quick Reference

```yaml
충돌 해결:
  우선순위: 보안 > 설계 > 성능 > 구현
  근거 기반: 더 구체적인 근거 채택
  제3 의견: 어려울 때 추가 에이전트 활용
  에스컬레이션: 비즈니스 결정은 사용자에게

효율성:
  병렬화: 독립 작업은 한 메시지에 여러 Task
  모델 선택: opus(복잡) / sonnet(일반) / haiku(단순)
  직접 실행: 단순 작업은 Task 안 씀
  재시도: 피드백 → 다른 에이전트 → 분할 → 직접
```
