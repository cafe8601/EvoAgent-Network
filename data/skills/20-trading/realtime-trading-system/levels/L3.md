# L3: Fault Tolerance & Production Deployment

## Connection Recovery

### Robust Connection Manager
```python
import threading
from enum import Enum

class ConnectionState(Enum):
    DISCONNECTED = 0
    CONNECTING = 1
    CONNECTED = 2
    RECONNECTING = 3
    ERROR = 4

class ConnectionManager:
    def __init__(self, kiwoom, teleQ: Queue):
        self.kiwoom = kiwoom
        self.teleQ = teleQ
        self.state = ConnectionState.DISCONNECTED
        self.max_retries = 5
        self.retry_delay = 5
        self.heartbeat_interval = 30
        self.last_heartbeat = time.time()

        self._lock = threading.Lock()

    def connect(self) -> bool:
        """ì—°ê²° ì‹œë„ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)"""
        with self._lock:
            self.state = ConnectionState.CONNECTING

        for attempt in range(self.max_retries):
            try:
                self.kiwoom.comm_connect()
                with self._lock:
                    self.state = ConnectionState.CONNECTED
                self.teleQ.put(('ALERT', 'âœ… API ì—°ê²° ì„±ê³µ'))
                return True

            except Exception as e:
                self.teleQ.put(('ALERT', f'âš ï¸ ì—°ê²° ì‹¤íŒ¨ (ì‹œë„ {attempt+1}/{self.max_retries}): {e}'))
                time.sleep(self.retry_delay * (attempt + 1))

        with self._lock:
            self.state = ConnectionState.ERROR
        return False

    def check_connection(self) -> bool:
        """ì—°ê²° ìƒíƒœ í™•ì¸ ë° ì¬ì—°ê²°"""
        if time.time() - self.last_heartbeat > self.heartbeat_interval:
            try:
                # Simple API call to check connection
                self.kiwoom.get_option_atm()
                self.last_heartbeat = time.time()
                return True
            except:
                return self.reconnect()
        return True

    def reconnect(self) -> bool:
        """ì¬ì—°ê²°"""
        with self._lock:
            self.state = ConnectionState.RECONNECTING

        self.teleQ.put(('ALERT', 'ğŸ”„ ì¬ì—°ê²° ì‹œë„ ì¤‘...'))
        return self.connect()

    def on_disconnect(self, error_code: int):
        """ì—°ê²° ëŠê¹€ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬"""
        error_messages = {
            -100: 'ì‚¬ìš©ì ìš”ì²­ ì—°ê²°ëŠê¹€',
            -101: 'ì„œë²„ ì ‘ì† ì‹¤íŒ¨',
            -102: 'ë²„ì „ ì—…ë°ì´íŠ¸ í•„ìš”',
            -103: 'ë³´ì•ˆ ëª¨ë“ˆ ì˜¤ë¥˜',
            -104: 'ì¸ì¦ì„œ ì˜¤ë¥˜'
        }

        msg = error_messages.get(error_code, f'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜: {error_code}')
        self.teleQ.put(('ALERT', f'âŒ ì—°ê²° ëŠê¹€: {msg}'))

        if error_code != -100:  # ì‚¬ìš©ì ìš”ì²­ì´ ì•„ë‹Œ ê²½ìš° ì¬ì—°ê²°
            threading.Thread(target=self.reconnect, daemon=True).start()
```

## Order State Machine

### Robust Order Manager
```python
from enum import Enum
from dataclasses import dataclass
from typing import Optional
import threading

class OrderState(Enum):
    PENDING = 'pending'        # ì£¼ë¬¸ ì „ì†¡ ëŒ€ê¸°
    SUBMITTED = 'submitted'    # ì£¼ë¬¸ ì „ì†¡ ì™„ë£Œ
    ACCEPTED = 'accepted'      # ì£¼ë¬¸ ì ‘ìˆ˜
    PARTIAL = 'partial'        # ë¶€ë¶„ ì²´ê²°
    FILLED = 'filled'          # ì „ëŸ‰ ì²´ê²°
    CANCELLED = 'cancelled'    # ì·¨ì†Œ
    REJECTED = 'rejected'      # ê±°ë¶€
    EXPIRED = 'expired'        # ë§Œë£Œ

@dataclass
class Order:
    order_id: str
    code: str
    side: str
    qty: int
    price: float
    order_type: str
    state: OrderState = OrderState.PENDING
    filled_qty: int = 0
    avg_fill_price: float = 0
    created_at: float = 0
    updated_at: float = 0
    error_msg: Optional[str] = None

class OrderStateMachine:
    def __init__(self, strategyQ: Queue, teleQ: Queue):
        self.strategyQ = strategyQ
        self.teleQ = teleQ
        self.orders = {}  # order_id -> Order
        self._lock = threading.RLock()

        # Valid state transitions
        self.transitions = {
            OrderState.PENDING: [OrderState.SUBMITTED, OrderState.REJECTED],
            OrderState.SUBMITTED: [OrderState.ACCEPTED, OrderState.REJECTED],
            OrderState.ACCEPTED: [OrderState.PARTIAL, OrderState.FILLED, OrderState.CANCELLED],
            OrderState.PARTIAL: [OrderState.FILLED, OrderState.CANCELLED],
        }

    def create_order(self, order_info: dict) -> Order:
        """ìƒˆ ì£¼ë¬¸ ìƒì„±"""
        order_id = self.generate_order_id()
        order = Order(
            order_id=order_id,
            code=order_info['code'],
            side=order_info['side'],
            qty=order_info['qty'],
            price=order_info.get('price', 0),
            order_type=order_info.get('order_type', '3'),
            created_at=time.time()
        )

        with self._lock:
            self.orders[order_id] = order

        return order

    def transition(self, order_id: str, new_state: OrderState,
                  fill_qty: int = 0, fill_price: float = 0) -> bool:
        """ìƒíƒœ ì „ì´"""
        with self._lock:
            order = self.orders.get(order_id)
            if not order:
                return False

            if new_state not in self.transitions.get(order.state, []):
                self.teleQ.put(('ALERT',
                    f'âš ï¸ ì˜ëª»ëœ ìƒíƒœ ì „ì´: {order.state} â†’ {new_state}'))
                return False

            old_state = order.state
            order.state = new_state
            order.updated_at = time.time()

            if fill_qty > 0:
                # í‰ê·  ì²´ê²°ê°€ ê³„ì‚°
                total_value = order.avg_fill_price * order.filled_qty + fill_price * fill_qty
                order.filled_qty += fill_qty
                order.avg_fill_price = total_value / order.filled_qty

            # Strategyì— ìƒíƒœ ë³€ê²½ ì•Œë¦¼
            self.strategyQ.put(('ORDER_STATE', {
                'order_id': order_id,
                'old_state': old_state.value,
                'new_state': new_state.value,
                'filled_qty': order.filled_qty,
                'remaining_qty': order.qty - order.filled_qty
            }))

            return True

    def get_pending_orders(self, code: str = None) -> list:
        """ë¯¸ì²´ê²° ì£¼ë¬¸ ì¡°íšŒ"""
        with self._lock:
            pending = [
                o for o in self.orders.values()
                if o.state in [OrderState.SUBMITTED, OrderState.ACCEPTED, OrderState.PARTIAL]
            ]
            if code:
                pending = [o for o in pending if o.code == code]
            return pending

    def generate_order_id(self) -> str:
        return f"ORD{int(time.time()*1000)}"
```

## Database Persistence

### Trade Logger with SQLite
```python
import sqlite3
from contextlib import contextmanager
from typing import Generator

class TradeDatabase:
    def __init__(self, db_path: str = 'trades.db'):
        self.db_path = db_path
        self.init_database()

    def init_database(self):
        with self.get_connection() as conn:
            conn.executescript('''
                CREATE TABLE IF NOT EXISTS orders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id TEXT UNIQUE,
                    code TEXT,
                    side TEXT,
                    qty INTEGER,
                    price REAL,
                    order_type TEXT,
                    state TEXT,
                    filled_qty INTEGER,
                    avg_fill_price REAL,
                    created_at REAL,
                    updated_at REAL,
                    strategy TEXT
                );

                CREATE TABLE IF NOT EXISTS fills (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id TEXT,
                    code TEXT,
                    side TEXT,
                    qty INTEGER,
                    price REAL,
                    timestamp REAL,
                    pnl REAL,
                    FOREIGN KEY (order_id) REFERENCES orders(order_id)
                );

                CREATE TABLE IF NOT EXISTS positions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    code TEXT UNIQUE,
                    qty INTEGER,
                    avg_price REAL,
                    side TEXT,
                    unrealized_pnl REAL,
                    updated_at REAL
                );

                CREATE TABLE IF NOT EXISTS daily_pnl (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date TEXT UNIQUE,
                    realized_pnl REAL,
                    unrealized_pnl REAL,
                    total_pnl REAL,
                    trade_count INTEGER,
                    win_count INTEGER,
                    loss_count INTEGER
                );

                CREATE INDEX IF NOT EXISTS idx_orders_code ON orders(code);
                CREATE INDEX IF NOT EXISTS idx_orders_state ON orders(state);
                CREATE INDEX IF NOT EXISTS idx_fills_timestamp ON fills(timestamp);
            ''')

    @contextmanager
    def get_connection(self) -> Generator[sqlite3.Connection, None, None]:
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()

    def log_order(self, order: Order):
        with self.get_connection() as conn:
            conn.execute('''
                INSERT OR REPLACE INTO orders
                (order_id, code, side, qty, price, order_type, state,
                 filled_qty, avg_fill_price, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                order.order_id, order.code, order.side, order.qty,
                order.price, order.order_type, order.state.value,
                order.filled_qty, order.avg_fill_price,
                order.created_at, order.updated_at
            ))

    def log_fill(self, fill: dict):
        with self.get_connection() as conn:
            conn.execute('''
                INSERT INTO fills (order_id, code, side, qty, price, timestamp, pnl)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                fill['order_id'], fill['code'], fill['side'],
                fill['qty'], fill['price'], fill['timestamp'],
                fill.get('pnl', 0)
            ))

    def get_daily_summary(self, date: str) -> dict:
        with self.get_connection() as conn:
            row = conn.execute('''
                SELECT * FROM daily_pnl WHERE date = ?
            ''', (date,)).fetchone()

            if row:
                return dict(row)
            return None
```

## Performance Optimization

### Queue Batching
```python
class BatchedQueue:
    """ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ í ë˜í¼"""

    def __init__(self, queue: Queue, batch_size: int = 100,
                 flush_interval: float = 0.1):
        self.queue = queue
        self.batch_size = batch_size
        self.flush_interval = flush_interval
        self.buffer = []
        self.last_flush = time.time()
        self._lock = threading.Lock()

    def put(self, item):
        with self._lock:
            self.buffer.append(item)

            if (len(self.buffer) >= self.batch_size or
                time.time() - self.last_flush >= self.flush_interval):
                self._flush()

    def _flush(self):
        if self.buffer:
            self.queue.put(('BATCH', self.buffer.copy()))
            self.buffer.clear()
            self.last_flush = time.time()

    def flush_now(self):
        with self._lock:
            self._flush()
```

### Memory-Efficient Price Buffer
```python
from collections import deque
import numpy as np

class CircularBuffer:
    """ê³ ì • í¬ê¸° ìˆœí™˜ ë²„í¼ (numpy ê¸°ë°˜)"""

    def __init__(self, size: int, dtype=np.float64):
        self.size = size
        self.buffer = np.zeros(size, dtype=dtype)
        self.index = 0
        self.full = False

    def append(self, value):
        self.buffer[self.index] = value
        self.index = (self.index + 1) % self.size
        if self.index == 0:
            self.full = True

    def get_array(self) -> np.ndarray:
        if self.full:
            return np.concatenate([
                self.buffer[self.index:],
                self.buffer[:self.index]
            ])
        return self.buffer[:self.index]

    def __len__(self) -> int:
        return self.size if self.full else self.index
```

## Monitoring & Alerting

### System Health Monitor
```python
class SystemMonitor:
    def __init__(self, teleQ: Queue):
        self.teleQ = teleQ
        self.metrics = {
            'queue_sizes': {},
            'latencies': deque(maxlen=1000),
            'errors': deque(maxlen=100),
            'last_trade': None,
            'uptime_start': time.time()
        }

        self.thresholds = {
            'queue_warning': 1000,
            'queue_critical': 5000,
            'latency_warning': 100,  # ms
            'latency_critical': 500,
            'heartbeat_timeout': 60
        }

    def check_queue_health(self, queues: dict):
        """í ìƒíƒœ ëª¨ë‹ˆí„°ë§"""
        for name, q in queues.items():
            size = q.qsize()
            self.metrics['queue_sizes'][name] = size

            if size > self.thresholds['queue_critical']:
                self.teleQ.put(('ALERT', f'ğŸš¨ CRITICAL: {name} í ì ì²´ ({size})'))
            elif size > self.thresholds['queue_warning']:
                self.teleQ.put(('ALERT', f'âš ï¸ WARNING: {name} í ì¦ê°€ ({size})'))

    def record_latency(self, operation: str, latency_ms: float):
        """ë ˆì´í„´ì‹œ ê¸°ë¡"""
        self.metrics['latencies'].append({
            'operation': operation,
            'latency': latency_ms,
            'timestamp': time.time()
        })

        if latency_ms > self.thresholds['latency_critical']:
            self.teleQ.put(('ALERT', f'ğŸš¨ ê³ ì§€ì—°: {operation} {latency_ms:.1f}ms'))

    def record_error(self, error: Exception, context: str):
        """ì—ëŸ¬ ê¸°ë¡"""
        self.metrics['errors'].append({
            'error': str(error),
            'context': context,
            'timestamp': time.time()
        })

    def get_health_report(self) -> dict:
        """ê±´ê°• ìƒíƒœ ë¦¬í¬íŠ¸"""
        uptime = time.time() - self.metrics['uptime_start']
        latencies = [l['latency'] for l in self.metrics['latencies']]

        return {
            'uptime_hours': uptime / 3600,
            'queue_sizes': self.metrics['queue_sizes'],
            'avg_latency_ms': np.mean(latencies) if latencies else 0,
            'max_latency_ms': max(latencies) if latencies else 0,
            'error_count': len(self.metrics['errors']),
            'last_trade': self.metrics['last_trade']
        }
```

## Graceful Shutdown

### Shutdown Handler
```python
import signal
import atexit

class GracefulShutdown:
    def __init__(self, qlist: list, db: TradeDatabase):
        self.qlist = qlist
        self.db = db
        self.shutdown_requested = threading.Event()

        # Register signal handlers
        signal.signal(signal.SIGINT, self.handle_signal)
        signal.signal(signal.SIGTERM, self.handle_signal)
        atexit.register(self.cleanup)

    def handle_signal(self, signum, frame):
        print(f"\nğŸ›‘ Shutdown signal received ({signum})")
        self.shutdown_requested.set()
        self.graceful_shutdown()

    def graceful_shutdown(self):
        """ë‹¨ê³„ì  ì¢…ë£Œ"""
        print("Step 1: Stopping new orders...")
        self.qlist[2].put(('STOP_NEW_ORDERS', None))

        print("Step 2: Cancelling pending orders...")
        self.cancel_all_pending_orders()

        print("Step 3: Closing all positions...")
        self.close_all_positions()

        print("Step 4: Flushing queues...")
        self.flush_all_queues()

        print("Step 5: Saving state...")
        self.save_final_state()

        print("Step 6: Sending final notifications...")
        self.qlist[4].put(('ALERT', 'ğŸ›‘ ì‹œìŠ¤í…œ ì¢…ë£Œ ì™„ë£Œ'))

        print("âœ… Graceful shutdown complete")

    def cancel_all_pending_orders(self):
        self.qlist[2].put(('CANCEL_ALL', None))
        time.sleep(2)  # Wait for cancellations

    def close_all_positions(self):
        self.qlist[2].put(('CLOSE_ALL', {'reason': 'shutdown'}))
        time.sleep(5)  # Wait for closes

    def flush_all_queues(self):
        for q in self.qlist:
            while not q.empty():
                try:
                    q.get_nowait()
                except:
                    break

    def save_final_state(self):
        # Save current positions, pending orders, etc.
        pass

    def cleanup(self):
        """ìµœì¢… ì •ë¦¬"""
        if not self.shutdown_requested.is_set():
            self.graceful_shutdown()
```

## Production Deployment Checklist

```yaml
pre_deployment:
  - [ ] ëª¨ì˜íˆ¬ì í…ŒìŠ¤íŠ¸ ì™„ë£Œ (ìµœì†Œ 1ì£¼ì¼)
  - [ ] ì—ëŸ¬ í•¸ë“¤ë§ ê²€ì¦
  - [ ] ì¬ì—°ê²° ë¡œì§ í…ŒìŠ¤íŠ¸
  - [ ] ì†ì ˆ ë¡œì§ ê²€ì¦
  - [ ] ë§Œê¸°ì¼ ì²­ì‚° í…ŒìŠ¤íŠ¸

environment:
  - [ ] ì „ìš© Windows ì„œë²„
  - [ ] UPS ì „ì› ë³´í˜¸
  - [ ] ì•ˆì •ì ì¸ ë„¤íŠ¸ì›Œí¬
  - [ ] ì›ê²© ì ‘ì† ì„¤ì •

monitoring:
  - [ ] Telegram ì•Œë¦¼ ì„¤ì •
  - [ ] ì›ê²© ëª¨ë‹ˆí„°ë§ ë„êµ¬
  - [ ] ìë™ ì¬ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸
  - [ ] ì¼ì¼ ë¦¬í¬íŠ¸ ìë™í™”

risk_management:
  - [ ] ì¼ì¼ ìµœëŒ€ ì†ì‹¤ í•œë„ ì„¤ì •
  - [ ] í¬ì§€ì…˜ í•œë„ ì„¤ì •
  - [ ] ë¹„ìƒ ì²­ì‚° ë²„íŠ¼
  - [ ] ë°±ì—… ìˆ˜ë™ ì²­ì‚° ë°©ë²•
```
