# L2: Queue Patterns & Signal Flow

## System Initialization

### Main Entry Point
```python
from multiprocessing import Process, Queue
import sys
from PyQt5.QtWidgets import QApplication

def main():
    # Create shared queues
    windowQ = Queue()
    receiverQ = Queue()
    traderQ = Queue()
    strategyQ = Queue()
    teleQ = Queue()
    queryQ = Queue()

    qlist = [windowQ, receiverQ, traderQ, strategyQ, teleQ, queryQ]

    # Start sub-processes (daemon=True for auto-cleanup)
    Process(target=start_receiver, args=(qlist,), daemon=True).start()
    Process(target=start_strategy, args=(qlist,), daemon=True).start()
    Process(target=start_trader, args=(qlist,), daemon=True).start()
    Process(target=start_telegram, args=(qlist,), daemon=True).start()

    # Start GUI in main process
    app = QApplication(sys.argv)
    window = TradingGUI(qlist)
    window.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
```

## Receiver Process

### Market Data Handler
```python
class Receiver:
    def __init__(self, qlist: list):
        self.windowQ = qlist[0]
        self.receiverQ = qlist[1]
        self.teleQ = qlist[4]

        # API connection
        self.kiwoom = Kiwoom(self, 'Receiver')
        self.kiwoom.comm_connect()

        # Price buffers
        self.price_buffer = {}  # code -> deque of prices
        self.buffer_size = 1000

    def OnReceiveRealData(self, code: str, realtype: str, realdata: str):
        """실시간 데이터 수신 콜백"""
        if realtype == '옵션시세':
            price_data = self.parse_option_price(code)
            self.update_buffer(code, price_data)
            self.receiverQ.put(('PRICE', code, price_data))
            self.windowQ.put(('PRICE_UPDATE', code, price_data))

        elif realtype == '옵션호가잔량':
            orderbook = self.parse_orderbook(code)
            self.receiverQ.put(('ORDERBOOK', code, orderbook))

    def parse_option_price(self, code: str) -> dict:
        return {
            'price': abs(int(self.kiwoom.get_comm_real_data(code, 10))),
            'change': int(self.kiwoom.get_comm_real_data(code, 11)),
            'volume': int(self.kiwoom.get_comm_real_data(code, 15)),
            'time': self.kiwoom.get_comm_real_data(code, 20).strip(),
            'timestamp': time.time()
        }

    def update_buffer(self, code: str, data: dict):
        if code not in self.price_buffer:
            from collections import deque
            self.price_buffer[code] = deque(maxlen=self.buffer_size)
        self.price_buffer[code].append(data)
```

## Strategy Process

### Signal Generator with Technical Indicators
```python
import talib
import numpy as np

class Strategy:
    def __init__(self, qlist: list):
        self.windowQ = qlist[0]
        self.receiverQ = qlist[1]
        self.traderQ = qlist[2]
        self.strategyQ = qlist[3]
        self.teleQ = qlist[4]

        # Load configuration
        self.config = self.load_config()

        # Price history for indicators
        self.ohlcv = {}  # code -> {'open': [], 'high': [], 'low': [], 'close': [], 'volume': []}

        # Position state
        self.positions = {}

    def run(self):
        """메인 이벤트 루프"""
        while True:
            # Process market data
            if not self.receiverQ.empty():
                msg = self.receiverQ.get()
                self.handle_market_data(msg)

            # Process trader feedback
            if not self.strategyQ.empty():
                msg = self.strategyQ.get()
                self.handle_trader_feedback(msg)

    def handle_market_data(self, msg: tuple):
        msg_type, code, data = msg

        if msg_type == 'PRICE':
            self.update_ohlcv(code, data)
            signal = self.calculate_signal(code)

            if signal:
                self.execute_signal(code, signal)

    def calculate_signal(self, code: str) -> Optional[dict]:
        """기술적 지표 기반 시그널 생성"""
        if code not in self.ohlcv:
            return None

        ohlcv = self.ohlcv[code]
        if len(ohlcv['close']) < 50:  # 최소 데이터 필요
            return None

        close = np.array(ohlcv['close'], dtype=float)
        high = np.array(ohlcv['high'], dtype=float)
        low = np.array(ohlcv['low'], dtype=float)

        # 지표 계산
        rsi = talib.RSI(close, timeperiod=14)[-1]
        macd, macd_signal, _ = talib.MACD(close)
        stoch_k, stoch_d = talib.STOCH(high, low, close)
        adx = talib.ADX(high, low, close)[-1]

        # 시그널 로직
        buy_condition = (
            rsi < 30 and
            macd[-1] > macd_signal[-1] and
            stoch_k[-1] > stoch_d[-1] and
            adx > 25
        )

        sell_condition = (
            rsi > 70 and
            macd[-1] < macd_signal[-1] and
            stoch_k[-1] < stoch_d[-1]
        )

        if buy_condition:
            return {'action': 'BUY', 'strength': 'STRONG' if rsi < 20 else 'NORMAL'}
        elif sell_condition:
            return {'action': 'SELL', 'strength': 'STRONG' if rsi > 80 else 'NORMAL'}

        return None
```

### TA-Lib Stream Functions
```python
class StreamIndicators:
    """실시간 스트리밍용 지표 계산"""

    def __init__(self, period: int = 14):
        self.period = period
        self.rsi_state = {'prev_avg_gain': 0, 'prev_avg_loss': 0}
        self.ema_state = {}

    def stream_rsi(self, prices: list) -> float:
        """스트리밍 RSI 계산"""
        return talib.stream_RSI(np.array(prices, dtype=float), self.period)

    def stream_stoch(self, high: list, low: list, close: list) -> tuple:
        """스트리밍 스토캐스틱"""
        return talib.stream_STOCH(
            np.array(high, dtype=float),
            np.array(low, dtype=float),
            np.array(close, dtype=float)
        )

    def stream_cci(self, high: list, low: list, close: list) -> float:
        """스트리밍 CCI"""
        return talib.stream_CCI(
            np.array(high, dtype=float),
            np.array(low, dtype=float),
            np.array(close, dtype=float),
            self.period
        )
```

### Custom ADX Calculation (Numpy)
```python
def calculate_adx_numpy(high: np.ndarray, low: np.ndarray, close: np.ndarray,
                        di_len: int = 14, adx_len: int = 14) -> tuple:
    """Numpy 기반 ADX 계산 (TA-Lib과 동일한 결과)"""

    # True Range
    tr1 = high - low
    tr2 = np.abs(high - np.roll(close, 1))
    tr3 = np.abs(low - np.roll(close, 1))
    tr = np.maximum(tr1, np.maximum(tr2, tr3))

    # Directional Movement
    up_move = high - np.roll(high, 1)
    down_move = np.roll(low, 1) - low

    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0)
    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0)

    # Wilder's Smoothing
    def wilder_smooth(data: np.ndarray, period: int) -> np.ndarray:
        result = np.zeros_like(data)
        result[period-1] = np.mean(data[:period])
        for i in range(period, len(data)):
            result[i] = (result[i-1] * (period - 1) + data[i]) / period
        return result

    atr = wilder_smooth(tr, di_len)
    smooth_plus_dm = wilder_smooth(plus_dm, di_len)
    smooth_minus_dm = wilder_smooth(minus_dm, di_len)

    # DI+, DI-
    plus_di = 100 * smooth_plus_dm / atr
    minus_di = 100 * smooth_minus_dm / atr

    # ADX
    dx = 100 * np.abs(plus_di - minus_di) / (plus_di + minus_di)
    adx = wilder_smooth(dx, adx_len)

    return adx, plus_di, minus_di
```

## Trader Process

### Order Execution Engine
```python
class Trader:
    def __init__(self, qlist: list):
        self.windowQ = qlist[0]
        self.traderQ = qlist[2]
        self.strategyQ = qlist[3]
        self.teleQ = qlist[4]

        # API connection
        self.kiwoom = Kiwoom(self, 'Trader')
        self.kiwoom.comm_connect()

        # Order state
        self.pending_orders = {}    # order_no -> order_info
        self.filled_orders = {}     # order_no -> fill_info
        self.positions = {}         # code -> position_info

    def run(self):
        while True:
            if not self.traderQ.empty():
                msg = self.traderQ.get()
                self.handle_order_request(msg)

            pythoncom.PumpWaitingMessages()
            time.sleep(0.001)

    def handle_order_request(self, msg: tuple):
        msg_type, data = msg

        if msg_type == 'ORDER':
            order_no = self.execute_order(data)
            if order_no:
                self.pending_orders[order_no] = data
                self.teleQ.put(('ORDER_SENT', data))

        elif msg_type == 'CANCEL':
            self.cancel_order(data['order_no'])

        elif msg_type == 'MODIFY':
            self.modify_order(data)

    def execute_order(self, order_info: dict) -> Optional[str]:
        """주문 실행"""
        order = [
            order_info['rqname'],
            str(order_info['screen_no']),
            self.account_no,
            order_info['code'],
            order_info['qty'],
            str(order_info.get('price', 0)),
            order_info.get('order_type', '3'),  # 시장가
            order_info['side'],  # 1=매수, 2=매도
            '',
            ''
        ]

        ret = self.kiwoom.send_order(order)
        if ret == 0:
            return order_info.get('order_no')
        return None

    def on_receive_chejan_data(self, gubun: str, item_cnt: int, fid_list: str):
        """체결/잔고 데이터 수신"""
        if gubun == '0':  # 주문체결
            order_no = self.kiwoom.get_chejan_data(9203)
            status = self.kiwoom.get_chejan_data(913).strip()
            code = self.kiwoom.get_chejan_data(9001).strip()
            price = int(self.kiwoom.get_chejan_data(910))
            qty = int(self.kiwoom.get_chejan_data(911))

            if status == '체결':
                fill_info = {
                    'code': code,
                    'price': price,
                    'qty': qty,
                    'time': datetime.now().isoformat()
                }
                self.filled_orders[order_no] = fill_info
                self.strategyQ.put(('FILL', fill_info))
                self.teleQ.put(('ORDER_FILLED', fill_info))

                # Remove from pending
                self.pending_orders.pop(order_no, None)

        elif gubun == '1':  # 잔고변경
            self.update_positions()

    def update_positions(self):
        """포지션 업데이트"""
        code = self.kiwoom.get_chejan_data(9001).strip()
        qty = int(self.kiwoom.get_chejan_data(930))
        avg_price = float(self.kiwoom.get_chejan_data(931))

        if qty > 0:
            self.positions[code] = {
                'qty': qty,
                'avg_price': avg_price,
                'pnl': self.calculate_pnl(code, avg_price)
            }
        else:
            self.positions.pop(code, None)

        self.windowQ.put(('POSITION_UPDATE', self.positions))
```

## GUI Integration

### PyQt5 Main Window
```python
from PyQt5.QtWidgets import (QMainWindow, QTableWidget, QTableWidgetItem,
                             QVBoxLayout, QHBoxLayout, QWidget, QPushButton)
from PyQt5.QtCore import QThread, pyqtSignal, QTimer

class TradingGUI(QMainWindow):
    def __init__(self, qlist: list):
        super().__init__()
        self.windowQ = qlist[0]

        self.init_ui()
        self.start_queue_worker()

    def init_ui(self):
        self.setWindowTitle('Trading System')
        self.setGeometry(100, 100, 1200, 800)

        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Position table
        self.position_table = QTableWidget()
        self.position_table.setColumnCount(5)
        self.position_table.setHorizontalHeaderLabels(
            ['종목코드', '수량', '평균가', '현재가', '손익']
        )
        layout.addWidget(self.position_table)

        # Control buttons
        btn_layout = QHBoxLayout()
        self.btn_start = QPushButton('시작')
        self.btn_stop = QPushButton('정지')
        self.btn_close_all = QPushButton('전량청산')
        btn_layout.addWidget(self.btn_start)
        btn_layout.addWidget(self.btn_stop)
        btn_layout.addWidget(self.btn_close_all)
        layout.addLayout(btn_layout)

    def start_queue_worker(self):
        self.worker = QueueWorker(self.windowQ)
        self.worker.update_signal.connect(self.handle_update)
        self.worker.start()

    def handle_update(self, msg: tuple):
        msg_type, *data = msg

        if msg_type == 'PRICE_UPDATE':
            code, price_data = data
            self.update_price_display(code, price_data)

        elif msg_type == 'POSITION_UPDATE':
            positions = data[0]
            self.update_position_table(positions)

        elif msg_type == 'LOG':
            message = data[0]
            self.append_log(message)

class QueueWorker(QThread):
    update_signal = pyqtSignal(tuple)

    def __init__(self, queue: Queue):
        super().__init__()
        self.queue = queue
        self.running = True

    def run(self):
        while self.running:
            if not self.queue.empty():
                msg = self.queue.get()
                self.update_signal.emit(msg)
            time.sleep(0.01)

    def stop(self):
        self.running = False
```

## Message Protocol

### Standard Message Format
```python
# Price data
('PRICE', code, {
    'price': 3.50,
    'change': 0.05,
    'volume': 1234,
    'time': '093015',
    'timestamp': 1699858215.123
})

# Order request
('ORDER', {
    'code': '201S6350',
    'side': '1',  # 1=BUY, 2=SELL
    'qty': 5,
    'price': 0,  # 0 = market order
    'order_type': '3',  # 시장가
    'rqname': 'STRATEGY_BUY'
})

# Fill notification
('FILL', {
    'order_no': '0012345',
    'code': '201S6350',
    'price': 3.50,
    'qty': 5,
    'side': 'BUY',
    'time': '2024-03-15T09:30:15'
})

# Position update
('POSITION_UPDATE', {
    '201S6350': {'qty': 5, 'avg_price': 3.48, 'pnl': 5000},
    '201T6350': {'qty': -3, 'avg_price': 2.10, 'pnl': -2500}
})

# Telegram alert
('ALERT', '⚠️ 손절 발동: 201S6350 -5틱')
('ORDER_FILLED', {'code': '201S6350', 'side': 'BUY', 'qty': 5, 'price': 3.50})
```

→ Load L3 for fault tolerance and production patterns
