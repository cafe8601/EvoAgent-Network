# L2: Trading Strategies & Position Management

## Multi-Level Profit Taking Strategy (분할익절)

### Configuration
```ini
[PROFIT]
# 6단계 익절 (틱 단위)
profitTick1 = 3    # 1차 익절: +3틱 (+7,500원/계약)
profitTick2 = 5    # 2차 익절: +5틱 (+12,500원/계약)
profitTick3 = 8    # 3차 익절: +8틱 (+20,000원/계약)
profitTick4 = 12   # 4차 익절: +12틱 (+30,000원/계약)
profitTick5 = 18   # 5차 익절: +18틱 (+45,000원/계약)
profitTick6 = 25   # 6차 익절: +25틱 (+62,500원/계약)

# 분할 비율
splitRatio1 = 0.20  # 1차: 20% 청산
splitRatio2 = 0.20  # 2차: 20% 청산
splitRatio3 = 0.20  # 3차: 20% 청산
splitRatio4 = 0.15  # 4차: 15% 청산
splitRatio5 = 0.15  # 5차: 15% 청산
splitRatio6 = 0.10  # 6차: 10% 청산 (전량)
```

### Implementation
```python
class ProfitTakingStrategy:
    def __init__(self, config: ConfigParser):
        self.profit_levels = [
            (config.getint('PROFIT', f'profitTick{i}'),
             config.getfloat('PROFIT', f'splitRatio{i}'))
            for i in range(1, 7)
        ]
        self.current_level = 0

    def check_profit_taking(self, entry_price: float, current_price: float,
                           position_qty: int, side: str) -> Optional[dict]:
        """익절 조건 확인 및 청산 수량 계산"""
        tick_size = 0.01  # 옵션 틱 사이즈

        if side == 'LONG':
            profit_ticks = (current_price - entry_price) / tick_size
        else:
            profit_ticks = (entry_price - current_price) / tick_size

        # 현재 레벨 이상의 익절 조건 확인
        for level, (target_ticks, ratio) in enumerate(self.profit_levels):
            if level <= self.current_level:
                continue

            if profit_ticks >= target_ticks:
                close_qty = int(position_qty * ratio)
                self.current_level = level

                return {
                    'action': 'CLOSE',
                    'qty': max(1, close_qty),
                    'reason': f'익절{level+1}차',
                    'profit_ticks': profit_ticks
                }

        return None
```

## Trailing Stop Loss (추적손절)

### Implementation
```python
class TrailingStopStrategy:
    def __init__(self, config: ConfigParser):
        self.stop_loss_tick = config.getint('STOPLOSS', 'stoplossTick')
        self.trailing_tick = config.getint('STOPLOSS', 'trailingStopTick')
        self.activation_tick = config.getint('STOPLOSS', 'activationTick')

        self.highest_profit = 0
        self.trailing_active = False

    def update_and_check(self, entry_price: float, current_price: float,
                        side: str) -> Optional[dict]:
        """추적손절 업데이트 및 청산 조건 확인"""
        tick_size = 0.01

        if side == 'LONG':
            profit_ticks = (current_price - entry_price) / tick_size
            loss_ticks = (entry_price - current_price) / tick_size
        else:
            profit_ticks = (entry_price - current_price) / tick_size
            loss_ticks = (current_price - entry_price) / tick_size

        # 1. 기본 손절 확인
        if loss_ticks >= self.stop_loss_tick:
            return {'action': 'CLOSE_ALL', 'reason': f'손절 (-{loss_ticks}틱)'}

        # 2. 추적손절 활성화
        if profit_ticks >= self.activation_tick:
            self.trailing_active = True
            self.highest_profit = max(self.highest_profit, profit_ticks)

        # 3. 추적손절 확인
        if self.trailing_active:
            drawdown = self.highest_profit - profit_ticks
            if drawdown >= self.trailing_tick:
                return {
                    'action': 'CLOSE_ALL',
                    'reason': f'추적손절 (고점 {self.highest_profit}틱 → 현재 {profit_ticks}틱)'
                }

        return None
```

## Time-Based Position Management

### Trading Time Rules
```python
from datetime import datetime, time

class TimeBasedManager:
    def __init__(self, config: ConfigParser):
        # 장 시작/종료
        self.market_open = time(9, 0)
        self.market_close = time(15, 45)

        # 매매 가능 시간
        self.trading_start = time(9, 5)    # 시초가 안정 후
        self.trading_end = time(15, 20)    # 종가 30분 전

        # 특수 시간대
        self.lunch_start = time(11, 30)
        self.lunch_end = time(13, 0)

        # 만기일 설정
        self.is_expiry = self.check_expiry_day()

    def can_open_position(self) -> tuple[bool, str]:
        """신규 진입 가능 여부"""
        now = datetime.now().time()

        if now < self.trading_start:
            return False, "장 초반 대기 중"
        if now > self.trading_end:
            return False, "종가 대기 시간"
        if self.lunch_start <= now <= self.lunch_end:
            return False, "점심시간 매매 제한"
        if self.is_expiry and now > time(14, 50):
            return False, "만기일 종가 청산 대기"

        return True, "매매 가능"

    def should_close_all(self) -> tuple[bool, str]:
        """전량 청산 필요 여부"""
        now = datetime.now().time()

        if now >= time(15, 35):
            return True, "종가 청산"
        if self.is_expiry and now >= time(15, 15):
            return True, "만기일 청산"

        return False, ""

    @staticmethod
    def check_expiry_day() -> bool:
        """매월 두번째 목요일 확인"""
        today = datetime.today()
        if today.weekday() != 3:  # 목요일
            return False

        # 두번째 목요일 계산
        first_day = today.replace(day=1)
        first_thursday = first_day + timedelta(days=(3 - first_day.weekday() + 7) % 7)
        second_thursday = first_thursday + timedelta(days=7)

        return today.date() == second_thursday.date()
```

## Option Selection Strategy

### ATM/OTM Selection
```python
class OptionSelector:
    def __init__(self, kiwoom):
        self.kiwoom = kiwoom

    def get_option_codes(self, option_type: str, offset: int = 0) -> dict:
        """
        option_type: 'call' or 'put'
        offset: ATM 기준 오프셋 (양수=OTM, 음수=ITM)
        """
        # ATM 행사가 조회
        atm_str = self.kiwoom.get_option_atm()
        atm_price = float(atm_str) * 100  # 35000

        # 행사가 간격 (2.5포인트)
        strike_gap = 250
        target_strike = int(atm_price + (offset * strike_gap))

        # 월물 조회
        month = self.kiwoom.get_month_list().split(';')[0]

        # 옵션 코드 생성
        opt_type_code = "2" if option_type == 'call' else "3"
        code = self.kiwoom.get_option_code(month, target_strike, opt_type_code)

        return {
            'code': code,
            'strike': target_strike / 100,
            'type': option_type,
            'moneyness': 'ATM' if offset == 0 else ('OTM' if offset > 0 else 'ITM')
        }

    def get_straddle_codes(self, offset: int = 0) -> dict:
        """스트래들용 콜/풋 코드 조회"""
        call = self.get_option_codes('call', offset)
        put = self.get_option_codes('put', offset)
        return {'call': call, 'put': put}
```

## Position P&L Calculation

### Real-time P&L
```python
class PositionPnL:
    def __init__(self):
        self.positions = {}  # code -> {qty, avg_price, side}
        self.tick_value = 2500  # 옵션 1틱 = 2,500원

    def update_position(self, code: str, qty: int, price: float, side: str):
        if code in self.positions:
            pos = self.positions[code]
            # 평균단가 계산
            total_qty = pos['qty'] + qty
            if total_qty > 0:
                pos['avg_price'] = (
                    (pos['avg_price'] * pos['qty'] + price * qty) / total_qty
                )
                pos['qty'] = total_qty
        else:
            self.positions[code] = {
                'qty': qty,
                'avg_price': price,
                'side': side
            }

    def calculate_pnl(self, code: str, current_price: float) -> dict:
        pos = self.positions.get(code)
        if not pos:
            return {'pnl': 0, 'pnl_pct': 0}

        tick_diff = (current_price - pos['avg_price']) / 0.01
        if pos['side'] == 'SHORT':
            tick_diff = -tick_diff

        pnl = tick_diff * self.tick_value * pos['qty']
        pnl_pct = (tick_diff * 0.01) / pos['avg_price'] * 100

        return {
            'pnl': pnl,
            'pnl_pct': pnl_pct,
            'ticks': tick_diff,
            'qty': pos['qty']
        }

    def get_total_pnl(self, current_prices: dict) -> float:
        total = 0
        for code, price in current_prices.items():
            result = self.calculate_pnl(code, price)
            total += result['pnl']
        return total
```

## Call/Put Separation Strategy

### Dual Strategy Runner
```python
class DualOptionStrategy:
    """콜/풋 분리 전략 실행"""

    def __init__(self, qlist: list):
        # 콜 전용 큐
        self.CallStrQ = qlist[3]
        # 풋 전용 큐
        self.PutStrQ = qlist[4]

        # 콜/풋 별도 포지션 관리
        self.call_position = PositionManager('call')
        self.put_position = PositionManager('put')

    def process_signal(self, signal: dict):
        """시그널에 따라 콜/풋 분기"""
        if signal['direction'] == 'BULLISH':
            # 콜 매수 또는 풋 매도
            self.CallStrQ.put({'action': 'BUY_CALL', **signal})
        elif signal['direction'] == 'BEARISH':
            # 풋 매수 또는 콜 매도
            self.PutStrQ.put({'action': 'BUY_PUT', **signal})
        elif signal['direction'] == 'NEUTRAL':
            # 스트래들/스트랭글
            self.CallStrQ.put({'action': 'STRADDLE_CALL', **signal})
            self.PutStrQ.put({'action': 'STRADDLE_PUT', **signal})
```

→ Load L3 for Greeks hedging and advanced strategies
