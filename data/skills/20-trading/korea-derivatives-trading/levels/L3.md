# L3: Advanced Strategies & Greeks Management

## Greeks Calculation

### Black-Scholes Greeks
```python
import numpy as np
from scipy.stats import norm
from dataclasses import dataclass

@dataclass
class OptionGreeks:
    delta: float
    gamma: float
    theta: float
    vega: float
    rho: float

class GreeksCalculator:
    def __init__(self, risk_free_rate: float = 0.035):
        self.r = risk_free_rate

    def calculate(self, S: float, K: float, T: float, sigma: float,
                 option_type: str) -> OptionGreeks:
        """
        S: Underlying price (KOSPI200 index)
        K: Strike price
        T: Time to expiry (years)
        sigma: Implied volatility
        option_type: 'call' or 'put'
        """
        d1 = (np.log(S / K) + (self.r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)

        if option_type == 'call':
            delta = norm.cdf(d1)
            theta = (-(S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))
                    - self.r * K * np.exp(-self.r * T) * norm.cdf(d2))
        else:
            delta = norm.cdf(d1) - 1
            theta = (-(S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))
                    + self.r * K * np.exp(-self.r * T) * norm.cdf(-d2))

        gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
        vega = S * norm.pdf(d1) * np.sqrt(T) / 100  # Per 1% IV change
        rho = (K * T * np.exp(-self.r * T) *
               (norm.cdf(d2) if option_type == 'call' else -norm.cdf(-d2))) / 100

        return OptionGreeks(
            delta=delta,
            gamma=gamma,
            theta=theta / 365,  # Daily theta
            vega=vega,
            rho=rho
        )
```

### Portfolio Greeks Aggregation
```python
class PortfolioGreeks:
    def __init__(self, calculator: GreeksCalculator):
        self.calc = calculator
        self.positions = []  # [(code, qty, side, strike, option_type)]

    def add_position(self, code: str, qty: int, side: str,
                    strike: float, option_type: str):
        multiplier = 1 if side == 'LONG' else -1
        self.positions.append({
            'code': code,
            'qty': qty * multiplier,
            'strike': strike,
            'type': option_type
        })

    def calculate_portfolio_greeks(self, underlying: float, T: float,
                                  iv_map: dict) -> dict:
        """포트폴리오 전체 그릭스 계산"""
        total_delta = 0
        total_gamma = 0
        total_theta = 0
        total_vega = 0

        for pos in self.positions:
            iv = iv_map.get(pos['code'], 0.20)  # Default 20% IV
            greeks = self.calc.calculate(
                S=underlying,
                K=pos['strike'],
                T=T,
                sigma=iv,
                option_type=pos['type']
            )

            total_delta += greeks.delta * pos['qty']
            total_gamma += greeks.gamma * pos['qty']
            total_theta += greeks.theta * pos['qty']
            total_vega += greeks.vega * pos['qty']

        # 계약 승수 적용 (250,000원)
        multiplier = 250000

        return {
            'delta': total_delta,
            'delta_exposure': total_delta * underlying * multiplier,
            'gamma': total_gamma,
            'theta': total_theta * multiplier,  # 일일 손익
            'vega': total_vega * multiplier      # IV 1% 변동 시 손익
        }
```

## Delta Hedging Strategy

### Dynamic Delta Hedge
```python
class DeltaHedger:
    def __init__(self, kiwoom, futures_code: str):
        self.kiwoom = kiwoom
        self.futures_code = futures_code
        self.hedge_threshold = 0.1  # 델타 0.1 이상 시 헤지
        self.futures_multiplier = 250000

    def calculate_hedge_qty(self, portfolio_delta: float,
                           futures_price: float) -> int:
        """선물 헤지 수량 계산"""
        # 선물 1계약 델타 = 1
        hedge_qty = -round(portfolio_delta)
        return hedge_qty

    def execute_hedge(self, current_delta: float, futures_price: float):
        """델타 중립 헤지 실행"""
        if abs(current_delta) < self.hedge_threshold:
            return None

        hedge_qty = self.calculate_hedge_qty(current_delta, futures_price)
        if hedge_qty == 0:
            return None

        side = '1' if hedge_qty > 0 else '2'  # 1=매수, 2=매도
        order = [
            'HEDGE',           # rqname
            '9999',            # screen_no
            self.account,      # account
            self.futures_code, # code
            abs(hedge_qty),    # qty
            '0',               # price (시장가)
            '3',               # 시장가
            side,              # 매수/매도
            '',                # 주문번호
            ''                 # 원주문번호
        ]

        return self.kiwoom.send_order(order)
```

## Spread Strategies

### Vertical Spread (수직 스프레드)
```python
class VerticalSpread:
    """불/베어 스프레드 전략"""

    def __init__(self, option_selector: OptionSelector):
        self.selector = option_selector

    def bull_call_spread(self, lower_strike_offset: int,
                        upper_strike_offset: int) -> dict:
        """불 콜 스프레드: 낮은 행사가 매수, 높은 행사가 매도"""
        long_call = self.selector.get_option_codes('call', lower_strike_offset)
        short_call = self.selector.get_option_codes('call', upper_strike_offset)

        return {
            'strategy': 'BULL_CALL_SPREAD',
            'legs': [
                {'action': 'BUY', **long_call},
                {'action': 'SELL', **short_call}
            ],
            'max_profit': (short_call['strike'] - long_call['strike']) * 250000,
            'max_loss': 'net_debit'
        }

    def bear_put_spread(self, lower_strike_offset: int,
                       upper_strike_offset: int) -> dict:
        """베어 풋 스프레드: 높은 행사가 매수, 낮은 행사가 매도"""
        long_put = self.selector.get_option_codes('put', upper_strike_offset)
        short_put = self.selector.get_option_codes('put', lower_strike_offset)

        return {
            'strategy': 'BEAR_PUT_SPREAD',
            'legs': [
                {'action': 'BUY', **long_put},
                {'action': 'SELL', **short_put}
            ],
            'max_profit': (long_put['strike'] - short_put['strike']) * 250000,
            'max_loss': 'net_debit'
        }
```

### Straddle/Strangle
```python
class VolatilityStrategies:
    """변동성 매매 전략"""

    def __init__(self, option_selector: OptionSelector):
        self.selector = option_selector

    def long_straddle(self, strike_offset: int = 0) -> dict:
        """롱 스트래들: 같은 행사가 콜/풋 동시 매수"""
        call = self.selector.get_option_codes('call', strike_offset)
        put = self.selector.get_option_codes('put', strike_offset)

        return {
            'strategy': 'LONG_STRADDLE',
            'legs': [
                {'action': 'BUY', **call},
                {'action': 'BUY', **put}
            ],
            'breakeven_up': call['strike'] + 'premium',
            'breakeven_down': put['strike'] - 'premium'
        }

    def short_strangle(self, call_offset: int = 1,
                      put_offset: int = -1) -> dict:
        """숏 스트랭글: OTM 콜/풋 동시 매도"""
        call = self.selector.get_option_codes('call', call_offset)
        put = self.selector.get_option_codes('put', put_offset)

        return {
            'strategy': 'SHORT_STRANGLE',
            'legs': [
                {'action': 'SELL', **call},
                {'action': 'SELL', **put}
            ],
            'max_profit': 'premium_received',
            'risk': 'unlimited'
        }
```

## Weekly Options Strategy (위클리옵션)

### Weekly vs Monthly Selection
```python
class WeeklyOptionsTrader:
    """위클리옵션 전용 전략"""

    def __init__(self, kiwoom):
        self.kiwoom = kiwoom

    def get_weekly_codes(self, option_type: str, offset: int = 0) -> dict:
        """위클리옵션 코드 조회 (매주 목요일 만기)"""
        # 위클리 월물 리스트
        month_list = self.kiwoom.get_month_list()
        weekly_month = self._get_nearest_weekly(month_list)

        atm_str = self.kiwoom.get_option_atm()
        atm_price = float(atm_str) * 100

        strike_gap = 250
        target_strike = int(atm_price + (offset * strike_gap))

        opt_type_code = "2" if option_type == 'call' else "3"

        # 위클리 옵션 코드 (209 prefix)
        code = self.kiwoom.get_option_code(weekly_month, target_strike, opt_type_code)

        return {
            'code': code,
            'strike': target_strike / 100,
            'type': option_type,
            'expiry': 'weekly'
        }

    def _get_nearest_weekly(self, month_list: str) -> str:
        """가장 가까운 위클리 만기 조회"""
        weeks = month_list.split(';')
        # 위클리는 W1, W2, W3, W4, W5 형태
        for w in weeks:
            if w.startswith('W'):
                return w
        return weeks[0]

    def theta_decay_strategy(self) -> dict:
        """위클리 세타 수익 전략 (만기 2-3일 전)"""
        days_to_expiry = self._calculate_dte()

        if 2 <= days_to_expiry <= 3:
            # OTM 옵션 매도 (시간가치 빠른 소멸)
            return {
                'strategy': 'WEEKLY_THETA',
                'call': self.get_weekly_codes('call', offset=2),  # OTM call
                'put': self.get_weekly_codes('put', offset=-2),   # OTM put
                'action': 'SELL',
                'exit': 'expiry_or_50%_profit'
            }

        return {'strategy': 'WAIT', 'reason': f'DTE={days_to_expiry}'}
```

## Risk Management

### Position Sizing
```python
class PositionSizer:
    def __init__(self, max_portfolio_risk: float = 0.02):
        self.max_risk = max_portfolio_risk  # 포트폴리오의 2%

    def calculate_position_size(self, account_value: float,
                               stop_loss_ticks: int,
                               option_price: float) -> int:
        """리스크 기반 포지션 사이징"""
        tick_value = 2500
        max_loss = account_value * self.max_risk

        # 손절 시 최대 손실
        loss_per_contract = stop_loss_ticks * tick_value

        # 최대 계약 수
        max_contracts = int(max_loss / loss_per_contract)

        return max(1, max_contracts)

    def kelly_criterion(self, win_rate: float, avg_win: float,
                       avg_loss: float) -> float:
        """켈리 기준 포지션 비율"""
        if avg_loss == 0:
            return 0

        win_loss_ratio = avg_win / abs(avg_loss)
        kelly = (win_rate * win_loss_ratio - (1 - win_rate)) / win_loss_ratio

        # Half Kelly for safety
        return max(0, min(0.25, kelly * 0.5))
```

### Expiry Day Management
```python
class ExpiryDayManager:
    """만기일 포지션 관리"""

    def __init__(self):
        self.expiry_rules = {
            'close_all_time': time(15, 15),      # 15:15 전량 청산
            'no_new_position': time(14, 30),     # 14:30 이후 신규 진입 금지
            'reduce_position': time(13, 00),     # 13:00 이후 포지션 축소
            'atm_warning': 2.5                   # ATM 근접 경고 (2.5pt)
        }

    def manage_expiry_positions(self, positions: list,
                               underlying: float, atm: float) -> list:
        """만기일 포지션 관리 로직"""
        actions = []
        now = datetime.now().time()

        for pos in positions:
            distance_from_atm = abs(pos['strike'] - atm)

            # ITM 깊숙히 들어간 옵션 - 청산
            if distance_from_atm > 5.0 and pos['moneyness'] == 'ITM':
                actions.append({
                    'action': 'CLOSE',
                    'code': pos['code'],
                    'reason': 'Deep ITM - exercise risk'
                })

            # ATM 근접 경고
            elif distance_from_atm < self.expiry_rules['atm_warning']:
                actions.append({
                    'action': 'ALERT',
                    'code': pos['code'],
                    'reason': f'ATM proximity: {distance_from_atm}pt'
                })

            # 시간 기반 청산
            if now >= self.expiry_rules['close_all_time']:
                actions.append({
                    'action': 'CLOSE_ALL',
                    'reason': 'Expiry day close-out'
                })

        return actions
```

## Performance Analytics

### Strategy Performance Tracker
```python
class StrategyAnalytics:
    def __init__(self, db_path: str):
        self.conn = sqlite3.connect(db_path)

    def calculate_metrics(self, start_date: str, end_date: str) -> dict:
        """전략 성과 지표 계산"""
        query = '''
            SELECT date, pnl FROM daily_pnl
            WHERE date BETWEEN ? AND ?
            ORDER BY date
        '''
        df = pd.read_sql(query, self.conn, params=[start_date, end_date])

        returns = df['pnl'].pct_change().dropna()

        metrics = {
            'total_return': df['pnl'].sum(),
            'win_rate': (df['pnl'] > 0).mean(),
            'profit_factor': abs(df[df['pnl'] > 0]['pnl'].sum() /
                               df[df['pnl'] < 0]['pnl'].sum()),
            'max_drawdown': self._calculate_max_drawdown(df['pnl'].cumsum()),
            'sharpe_ratio': returns.mean() / returns.std() * np.sqrt(252),
            'avg_daily_pnl': df['pnl'].mean(),
            'best_day': df['pnl'].max(),
            'worst_day': df['pnl'].min()
        }

        return metrics

    def _calculate_max_drawdown(self, cumulative: pd.Series) -> float:
        peak = cumulative.expanding().max()
        drawdown = (cumulative - peak) / peak
        return drawdown.min()
```
