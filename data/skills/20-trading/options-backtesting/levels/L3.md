# L3: Custom Strategy Implementation & Advanced Optimization

## Custom Strategy via Inheritance

### BaseUniversalStrategy Class

```python
from backtesting_engine import (
    BaseUniversalStrategy,
    UniversalStrategyConfig,
    MultiLegPosition,
    MarketSnapshot,
    OptionLeg,
    OptionType,
    PositionDirection,
    StrategyType,
    ExitConditionBuilder,
    OPTION_MULTIPLIER,
)
from datetime import time

class MyCustomStrategy(BaseUniversalStrategy):
    """나만의 커스텀 전략"""

    def __init__(self):
        # 설정 생성
        config = UniversalStrategyConfig(
            strategy_name="MyCustomStrategy",
            strategy_type=StrategyType.LONG_STRADDLE,
            initial_capital=100_000_000,
            invest_per_trade=10_000_000,
        )

        # 청산 조건 추가
        config.add_exit_condition(ExitConditionBuilder.rr_target(2.0))
        config.add_exit_condition(ExitConditionBuilder.stop_loss(20.0))
        config.add_exit_condition(ExitConditionBuilder.time_exit(time(15, 15)))

        super().__init__(config)

        # 커스텀 변수
        self.entry_count = 0
        self.max_iv_for_entry = 30.0
        self.min_iv_for_entry = 15.0

    def check_entry_condition(self, snapshot: MarketSnapshot) -> bool:
        """진입 조건 확인"""
        # ATM 옵션 존재 확인
        call, put = snapshot.get_atm_options()
        if call is None or put is None:
            return False

        # IV가 특정 범위일 때만 진입
        avg_iv = (call.greeks.iv + put.greeks.iv) / 2
        if not (self.min_iv_for_entry <= avg_iv <= self.max_iv_for_entry):
            return False

        # 델타가 거의 중립일 때만
        net_delta = abs(call.greeks.delta + put.greeks.delta)
        if net_delta > 0.1:
            return False

        return True

    def create_position(self, snapshot: MarketSnapshot) -> MultiLegPosition:
        """포지션 생성"""
        call_tick, put_tick = snapshot.get_atm_options()

        # 수량 계산
        premium = call_tick.ask_price + put_tick.ask_price
        position_value = premium * OPTION_MULTIPLIER
        quantity = max(1, int(self.config.invest_per_trade / position_value))

        # 콜 레그 생성
        call_leg = OptionLeg(
            code=call_tick.code,
            option_type=OptionType.CALL,
            direction=PositionDirection.LONG,
            strike_price=call_tick.strike_price,
            entry_price=call_tick.ask_price,
            current_price=call_tick.price,
            quantity=quantity,
            greeks=call_tick.greeks,
        )

        # 풋 레그 생성
        put_leg = OptionLeg(
            code=put_tick.code,
            option_type=OptionType.PUT,
            direction=PositionDirection.LONG,
            strike_price=put_tick.strike_price,
            entry_price=put_tick.ask_price,
            current_price=put_tick.price,
            quantity=quantity,
            greeks=put_tick.greeks,
        )

        self.entry_count += 1

        return MultiLegPosition(
            strategy_type=StrategyType.LONG_STRADDLE,
            legs=[call_leg, put_leg],
            atm_strike=snapshot.atm_strike,
        )

# 사용
strategy = MyCustomStrategy()
engine = UniversalOptionBacktestEngine(strategy)
results = engine.run(snapshots)
```

---

## Custom Exit Conditions

### Creating Custom Exit Logic

```python
from backtesting_engine import ExitCondition, ExitType

def my_custom_condition(pos: MultiLegPosition,
                        snapshot: MarketSnapshot,
                        config: UniversalStrategyConfig) -> Tuple[bool, int, str]:
    """
    커스텀 청산 조건

    Returns:
        Tuple[should_exit, exit_quantity, exit_reason]
    """
    # 포지션 그리스 계산
    position_greeks = pos.get_total_greeks()

    # 델타가 너무 커지면 청산
    if abs(position_greeks.delta) > 0.5:
        return True, pos.legs[0].quantity, "델타 임계값 초과"

    # 감마 익스포져가 너무 크면 청산
    if position_greeks.gamma > 0.1:
        return True, pos.legs[0].quantity, "감마 익스포져 과다"

    # 세타 손실이 프리미엄의 50% 초과 시
    theta_loss = abs(position_greeks.theta) * pos.holding_minutes
    if theta_loss > pos.entry_premium * 0.5:
        return True, pos.legs[0].quantity, "세타 손실 과다"

    return False, 0, ""

# 커스텀 청산 조건 등록
custom_exit = ExitCondition(
    exit_type=ExitType.INDICATOR_EXIT,
    priority=12,
    condition_fn=my_custom_condition,
)

config.add_exit_condition(custom_exit)
```

---

## Advanced Strategy Templates

### IV-Aware Strategy

```python
@StrategyTemplateRegistry.register("long_straddle_iv_aware")
class LongStraddleIVAware(BaseUniversalStrategy):
    """IV 인식 롱 스트래들 - IV 낮을 때만 진입"""

    def __init__(self, max_entry_iv: float = 25.0, **kwargs):
        config = UniversalStrategyConfig(
            strategy_name="LongStraddle_IV_Aware",
            strategy_type=StrategyType.LONG_STRADDLE,
        )

        # IV Crush 청산 활용
        config.add_exit_condition(ExitConditionBuilder.iv_crush(0.15, priority=3))
        config.add_exit_condition(ExitConditionBuilder.rr_target(2.0, priority=10))
        config.add_exit_condition(ExitConditionBuilder.stop_loss(15.0, priority=5))

        super().__init__(config)
        self.max_entry_iv = max_entry_iv

    def check_entry_condition(self, snapshot: MarketSnapshot) -> bool:
        call, put = snapshot.get_atm_options()
        if call is None or put is None:
            return False

        # IV가 낮을 때만 진입 (저렴할 때 매수)
        avg_iv = (call.greeks.iv + put.greeks.iv) / 2
        return avg_iv <= self.max_entry_iv
```

### Delta Neutral Strategy

```python
@StrategyTemplateRegistry.register("delta_neutral_straddle")
class DeltaNeutralStraddle(BaseUniversalStrategy):
    """델타 중립 스트래들 - 델타 이탈 시 청산"""

    def __init__(self, max_entry_delta: float = 0.1,
                 max_position_delta: float = 0.3, **kwargs):
        config = UniversalStrategyConfig(
            strategy_name="DeltaNeutral_Straddle",
            strategy_type=StrategyType.LONG_STRADDLE,
        )

        # 델타 임계값 청산
        config.add_exit_condition(
            ExitConditionBuilder.delta_threshold(max_position_delta, priority=8)
        )
        config.add_exit_condition(ExitConditionBuilder.rr_target(1.5, priority=10))
        config.add_exit_condition(ExitConditionBuilder.stop_loss(20.0, priority=5))

        super().__init__(config)
        self.max_entry_delta = max_entry_delta

    def check_entry_condition(self, snapshot: MarketSnapshot) -> bool:
        call, put = snapshot.get_atm_options()
        if call is None or put is None:
            return False

        # 델타 중립일 때만 진입
        net_delta = abs(call.greeks.delta + put.greeks.delta)
        return net_delta <= self.max_entry_delta
```

### Iron Condor Strategy

```python
@StrategyTemplateRegistry.register("iron_condor")
class IronCondorStrategy(BaseUniversalStrategy):
    """아이언 콘도르 - 제한 손익, 횡보장 전략"""

    def __init__(self,
                 call_short_offset: float = 5.0,
                 call_long_offset: float = 7.5,
                 put_short_offset: float = 5.0,
                 put_long_offset: float = 7.5,
                 **kwargs):
        config = UniversalStrategyConfig(
            strategy_name="IronCondor",
            strategy_type=StrategyType.IRON_CONDOR,
        )

        config.add_exit_condition(ExitConditionBuilder.profit_target(50.0, priority=10))
        config.add_exit_condition(ExitConditionBuilder.stop_loss(100.0, priority=5))  # 최대손실 제한
        config.add_exit_condition(ExitConditionBuilder.time_exit(time(15, 15), priority=1))

        super().__init__(config)
        self.call_short_offset = call_short_offset
        self.call_long_offset = call_long_offset
        self.put_short_offset = put_short_offset
        self.put_long_offset = put_long_offset

    def create_position(self, snapshot: MarketSnapshot) -> MultiLegPosition:
        """4레그 아이언 콘도르 생성"""
        atm = snapshot.atm_strike

        legs = [
            # Short Call (ATM + offset)
            self._create_leg(snapshot, OptionType.CALL, PositionDirection.SHORT,
                           atm + self.call_short_offset),
            # Long Call (ATM + larger offset)
            self._create_leg(snapshot, OptionType.CALL, PositionDirection.LONG,
                           atm + self.call_long_offset),
            # Short Put (ATM - offset)
            self._create_leg(snapshot, OptionType.PUT, PositionDirection.SHORT,
                           atm - self.put_short_offset),
            # Long Put (ATM - larger offset)
            self._create_leg(snapshot, OptionType.PUT, PositionDirection.LONG,
                           atm - self.put_long_offset),
        ]

        return MultiLegPosition(
            strategy_type=StrategyType.IRON_CONDOR,
            legs=legs,
            atm_strike=atm,
        )
```

---

## Multi-Strategy Comparison

```python
strategies = [
    StrategyTemplateRegistry.create("long_straddle_conservative"),
    StrategyTemplateRegistry.create("long_straddle_aggressive"),
    StrategyTemplateRegistry.create("long_straddle_iv_aware", max_entry_iv=25.0),
    StrategyTemplateRegistry.create("delta_neutral_straddle"),
]

results = []
for strategy in strategies:
    engine = UniversalOptionBacktestEngine(strategy)
    result = engine.run(snapshots)
    results.append(result)

# 비교 테이블 출력
print(f"{'전략명':30} {'PF':>8} {'승률':>8} {'MDD':>8} {'총손익':>15}")
print("-" * 75)
for r in results:
    print(f"{r['strategy_name']:30} "
          f"{r['profit_factor']:>8.2f} "
          f"{r['win_rate']*100:>7.1f}% "
          f"{r['max_drawdown']:>7.1f}% "
          f"{r['total_pnl']:>15,.0f}")
```

---

## Integration with data_storage

### Loading Real Tick Data

```python
import sys
sys.path.insert(0, '/path/to/tradingSystem')

from data_storage import BacktestDataExporter
from backtesting_engine import (
    StrategyTemplateRegistry,
    UniversalOptionBacktestEngine,
    create_engine_from_data_storage,
    run_backtest_from_exporter,
)

# 저장된 데이터 로드
exporter = BacktestDataExporter()

# 사용 가능한 날짜 확인
dates = exporter.get_available_dates()
print(f"사용 가능한 날짜: {dates}")

# 특정 날짜 데이터로 백테스트
date = "20250106"
strategy = StrategyTemplateRegistry.create("long_straddle_conservative")

# 간편 실행 함수 사용
results = run_backtest_from_exporter(
    exporter=exporter,
    date=date,
    strategy=strategy,
)
```

### OMG Data Mapping

```python
# OMG 피드에서 제공하는 Greeks 데이터
omg_data = {
    'delt': 0.5123,      # delta
    'gama': 0.0456,      # gamma
    'ceta': -0.0234,     # theta
    'vega': 0.1567,      # vega
    'rhox': 0.0089,      # rho
    'impv': 21.34,       # IV (내재변동성)
    'theoryprice': 3.52, # 이론가
}

# GreeksData 객체로 변환
greeks = GreeksData(
    delta=omg_data['delt'],
    gamma=omg_data['gama'],
    theta=omg_data['ceta'],
    vega=omg_data['vega'],
    rho=omg_data['rhox'],
    iv=omg_data['impv'],
    theoretical_price=omg_data['theoryprice'],
)
```

---

## Production Optimization Workflow

### Complete Optimization Pipeline

```python
from backtesting_engine import (
    OptionsOptimizer,
    ParameterRange,
    OptimizationMethod,
)
from datetime import date

# 1. 파라미터 범위 정의
parameter_ranges = [
    ParameterRange(
        name='stop_loss',
        min_value=5.0,
        max_value=30.0,
        step=5.0,
    ),
    ParameterRange(
        name='profit_target',
        min_value=50.0,
        max_value=200.0,
        step=25.0,
    ),
    ParameterRange(
        name='trailing_activation',
        min_value=30.0,
        max_value=100.0,
        step=10.0,
    ),
    ParameterRange(
        name='max_holding_minutes',
        min_value=10,
        max_value=60,
        step=10,
        is_integer=True,
    ),
]

# 2. 전략 템플릿 (최적화 대상)
strategy_template = {
    'name': 'OptimizedStraddle',
    'type': 'long_straddle',
    'parameters': {
        'stop_loss': 20.0,
        'profit_target': 100.0,
        'trailing_activation': 50.0,
        'max_holding_minutes': 30,
    },
    'buy': 'atm_straddle_entry',
    'sell': 'exit_conditions',
}

# 3. 최적화 실행
optimizer = OptionsOptimizer()

# Walk-forward로 과적합 방지
result = optimizer.walk_forward_optimize(
    strategy_template=strategy_template,
    parameter_ranges=parameter_ranges,
    contract_code="201FA",
    start_date=date(2024, 1, 1),
    end_date=date(2024, 12, 31),
)

# 4. 결과 분석
print(f"최적 파라미터: {result.best_parameters}")
print(f"Train Score: {result.train_score:.4f}")
print(f"Validation Score: {result.validation_score:.4f}")
print(f"Test Score: {result.test_score:.4f}")
print(f"Overfitting Ratio: {result.overfitting_ratio:.2f}")

# 과적합 경고
if result.overfitting_ratio > 1.5:
    print("⚠️ WARNING: High overfitting detected!")
```

---

## Result Visualization with Pandas

```python
import pandas as pd

# 모든 최적화 결과를 DataFrame으로
all_results = optimization_results['all_results']
df = pd.DataFrame([
    {
        **r['params'],
        'profit_factor': r['profit_factor'],
        'win_rate': r['win_rate'],
        'total_pnl': r['total_pnl'],
        'max_drawdown': r['max_drawdown'],
        'total_trades': r['total_trades'],
    }
    for r in all_results
])

# Profit Factor 기준 상위 10개
print("Top 10 by Profit Factor:")
print(df.nlargest(10, 'profit_factor')[['stop_loss', 'profit_target',
                                         'profit_factor', 'win_rate', 'total_pnl']])

# 낙폭 기준 안정적인 조합
print("\nMost Stable (Lowest MDD):")
print(df.nsmallest(5, 'max_drawdown')[['stop_loss', 'profit_target',
                                        'max_drawdown', 'profit_factor']])

# 파라미터별 상관관계
print("\nParameter Correlations with Profit Factor:")
print(df[['stop_loss', 'profit_target', 'trailing_activation',
          'profit_factor']].corr()['profit_factor'])
```

---

## Constants Reference

```python
# KOSPI200 옵션 상수
OPTION_MULTIPLIER = 250_000   # 옵션 승수
OPTION_TICK_SIZE = 0.01       # 호가 단위

# KOSPI200 선물 상수
FUTURES_MULTIPLIER = 250_000  # 선물 승수
FUTURES_TICK_SIZE = 0.05      # 호가 단위

# 거래 시간
MARKET_OPEN = time(9, 0)
MARKET_CLOSE = time(15, 45)
OPTIONS_CLOSE = time(15, 20)  # 옵션 청산 마감
```

---

## Module Reference

```python
from backtesting_engine import (
    # Configuration
    EngineConfig, BacktestConfig, OptimizerConfig,
    OptimizationMethod, OptimizationStandard,

    # Data Structures
    MarketSnapshot, OptionTick, GreeksData,
    OptionLeg, MultiLegPosition, TradeResult,

    # Enums
    OptionType, PositionDirection, StrategyType, ExitType,

    # Exit Conditions
    ExitCondition, ExitConditionBuilder,

    # Strategies
    BaseUniversalStrategy, UniversalStrategyConfig,

    # Templates
    StrategyTemplateRegistry, CustomStrategyBuilder,

    # Engines
    UniversalOptionBacktestEngine, UniversalOptionOptimizer,

    # Optimization
    OptionsOptimizer, GridOptimizer, GeneticOptimizer,
    ParameterRange, OptimizationParameter,

    # Results
    BacktestResult, OptimizationResult, ResultsAnalyzer,

    # Integration
    create_engine_from_data_storage, run_backtest_from_exporter,
)
```

