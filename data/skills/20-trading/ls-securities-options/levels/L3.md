# L3: Order Management & Production Architecture

## C01 - 선물주문체결 (261 bytes)

### OutBlock (Output - 261 bytes)
| Field | Type | Size | Description |
|-------|------|------|-------------|
| lineseq | long | 10 | 라인일련번호 |
| **accno** | string | 11 | 계좌번호 |
| user | string | 8 | 조작자ID |
| seq | long | 11 | 일련번호 |
| trcode | string | 11 | trcode |
| megrpno | string | 2 | 매칭그룹번호 |
| boardid | string | 2 | 보드ID |
| memberno | string | 5 | 회원번호 |
| bpno | string | 5 | 지점번호 |
| **ordno** | string | 10 | 주문번호 |
| **orgordno** | string | 10 | 원주문번호 |
| **expcode** | string | 12 | 종목코드 |
| yakseq | string | 11 | 약정번호 |
| **cheprice** | float | 11.2 | 체결가격 |
| **chevol** | long | 10 | 체결수량 |
| sessionid | string | 2 | 세션ID |
| chedate | string | 8 | 체결일자 |
| **chetime** | string | 9 | 체결시각 |
| spdprc1 | float | 11.2 | 최근월체결가격 |
| spdprc2 | float | 11.2 | 차근월체결가격 |
| dosugb | string | 1 | 매도수구분 (1:매도, 2:매수) |
| accno1 | string | 12 | 계좌번호1 |
| sihogagb | string | 11 | 시장조성호가구분 |
| jakino | string | 5 | 위탁사번호 |
| daeyong | string | 12 | 대용주관계좌번호 |
| mem_filler | string | 7 | mem_filler |
| mem_accno | string | 11 | mem_accno |
| mem_filler1 | string | 42 | mem_filler1 |

### C01 Parser (체결 통보)
```python
class C01Parser:
    """선물주문체결 통보 파서"""

    def __init__(self, real: 'XAReal'):
        self.real = real

    def parse(self) -> dict:
        return {
            'order_no': self.real.GetFieldData("OutBlock", "ordno").strip(),
            'org_order_no': self.real.GetFieldData("OutBlock", "orgordno").strip(),
            'account': self.real.GetFieldData("OutBlock", "accno").strip(),
            'code': self.real.GetFieldData("OutBlock", "expcode").strip(),
            'fill_price': float(self.real.GetFieldData("OutBlock", "cheprice")),
            'fill_qty': int(self.real.GetFieldData("OutBlock", "chevol")),
            'fill_time': self.real.GetFieldData("OutBlock", "chetime").strip(),
            'fill_date': self.real.GetFieldData("OutBlock", "chedate").strip(),
            'side': 'SELL' if self.real.GetFieldData("OutBlock", "dosugb") == '1' else 'BUY',
            'seq': int(self.real.GetFieldData("OutBlock", "seq")),
            'yakseq': self.real.GetFieldData("OutBlock", "yakseq").strip()
        }
```

## H01 - 선물주문정정취소 (316 bytes)

### OutBlock (Output - 316 bytes)
| Field | Type | Size | Description |
|-------|------|------|-------------|
| lineseq | long | 10 | 라인일련번호 |
| accno | string | 11 | 계좌번호 |
| user | string | 8 | 조작자ID |
| seq | long | 11 | 일련번호 |
| trcode | string | 11 | trcode |
| megrpno | string | 2 | 매칭그룹번호 |
| boardid | string | 2 | 보드ID |
| memberno | string | 5 | 회원번호 |
| bpno | string | 5 | 지점번호 |
| **ordno** | string | 10 | 주문번호 |
| **orgordno** | string | 10 | 원주문번호 |
| expcode | string | 12 | 종목코드 |
| dosugb | string | 1 | 매도수구분 |
| **mocagb** | string | 1 | 정정취소구분 (1:정정, 2:취소) |
| accno1 | string | 12 | 계좌번호1 |
| **qty2** | long | 10 | 호가수량 |
| **price** | float | 11.2 | 호가가격 |
| ordgb | string | 1 | 주문유형 |
| hogagb | string | 1 | 호가구분 |
| sihogagb | string | 11 | 시장조성호가구분 |
| tradid | string | 5 | 자사주신고서ID |
| treacode | string | 1 | 자사주매매방법 |
| askcode | string | 2 | 매도유형코드 |
| creditcode | string | 2 | 신용구분코드 |
| jakigb | string | 2 | 위탁자기구분 |
| trustnum | string | 5 | 위탁사번호 |
| ptgb | string | 2 | 프로그램구분 |
| substonum | string | 12 | 대용주관계좌번호 |
| accgb | string | 2 | 계좌구분코드 |
| accmarggb | string | 2 | 계좌증거금코드 |
| nationcode | string | 3 | 국가코드 |
| investgb | string | 4 | 투자자구분 |
| forecode | string | 2 | 외국인코드 |
| medcode | string | 1 | 주문매체구분 |
| ordid | string | 12 | 주문식별자번호 |
| macid | string | 12 | MAC주소 |
| orddate | string | 8 | 호가일자 |
| rcvtime | string | 9 | 회원사주문시각 |
| mem_filler | string | 7 | mem_filler |
| mem_accno | string | 11 | mem_accno |
| mem_filler1 | string | 42 | mem_filler1 |
| ordacpttm | string | 9 | 매칭접수시간 |
| **qty** | long | 10 | 실정정취소수량 |
| autogb | string | 1 | 자동취소구분 |
| **rejcode** | string | 4 | 거부사유 |
| prgordde | string | 1 | 프로그램호가신고 |

### H01 Parser (정정/취소 통보)
```python
class H01Parser:
    """선물주문정정취소 통보 파서"""

    def __init__(self, real: 'XAReal'):
        self.real = real

    def parse(self) -> dict:
        moca_type = self.real.GetFieldData("OutBlock", "mocagb")

        return {
            'order_no': self.real.GetFieldData("OutBlock", "ordno").strip(),
            'org_order_no': self.real.GetFieldData("OutBlock", "orgordno").strip(),
            'account': self.real.GetFieldData("OutBlock", "accno").strip(),
            'code': self.real.GetFieldData("OutBlock", "expcode").strip(),
            'action': 'MODIFY' if moca_type == '1' else 'CANCEL',
            'qty': int(self.real.GetFieldData("OutBlock", "qty")),
            'price': float(self.real.GetFieldData("OutBlock", "price")),
            'side': 'SELL' if self.real.GetFieldData("OutBlock", "dosugb") == '1' else 'BUY',
            'reject_code': self.real.GetFieldData("OutBlock", "rejcode").strip(),
            'accept_time': self.real.GetFieldData("OutBlock", "ordacpttm").strip(),
            'is_auto_cancel': self.real.GetFieldData("OutBlock", "autogb") == '1'
        }
```

## O01 - 선물접수 (1141 bytes) - 상세 주문 정보

### Key Fields (중요 필드만)
| Field | Type | Size | Description |
|-------|------|------|-------------|
| accno | string | 11 | 계좌번호 |
| ordno | long | 7 | 주문번호 |
| orgordno | long | 7 | 원주문번호 |
| **ordprc** | double | 13.2 | 주문가격 |
| **ordqty** | long | 16 | 주문수량 |
| **execqty** | long | 16 | 체결수량 |
| **execprc** | double | 13.2 | 체결가격 |
| **unercqty** | long | 16 | 미체결수량 |
| **lqdtqty** | long | 16 | 청산체결수량 |
| fnotrdunitamt | double | 19.8 | 선물옵션거래단위금액 |
| ordableamt | long | 16 | 주문가능금액 |
| mnyordableamt | long | 16 | 미체결가능금액 |

### O01 Parser (접수 상세)
```python
class O01Parser:
    """선물접수 상세 파서"""

    def __init__(self, real: 'XAReal'):
        self.real = real

    def parse(self) -> dict:
        return {
            'account': self.real.GetFieldData("OutBlock", "accno").strip(),
            'order_no': int(self.real.GetFieldData("OutBlock", "ordno")),
            'org_order_no': int(self.real.GetFieldData("OutBlock", "orgordno")),
            'code': self.real.GetFieldData("OutBlock", "isuno").strip(),
            'order_price': float(self.real.GetFieldData("OutBlock", "ordprc")),
            'order_qty': int(self.real.GetFieldData("OutBlock", "ordqty")),
            'exec_qty': int(self.real.GetFieldData("OutBlock", "execqty")),
            'exec_price': float(self.real.GetFieldData("OutBlock", "execprc")),
            'unfilled_qty': int(self.real.GetFieldData("OutBlock", "unercqty")),
            'liquidate_qty': int(self.real.GetFieldData("OutBlock", "lqdtqty")),
            'available_amt': int(self.real.GetFieldData("OutBlock", "ordableamt")),
            'status': self._determine_status()
        }

    def _determine_status(self) -> str:
        exec_qty = int(self.real.GetFieldData("OutBlock", "execqty"))
        order_qty = int(self.real.GetFieldData("OutBlock", "ordqty"))
        unfilled = int(self.real.GetFieldData("OutBlock", "unercqty"))

        if exec_qty == order_qty:
            return 'FILLED'
        elif exec_qty > 0:
            return 'PARTIAL'
        elif unfilled == 0:
            return 'CANCELLED'
        else:
            return 'PENDING'
```

## Order Execution System

### CFOAT00100 - 선물옵션정상주문
```python
class LSOrderExecutor:
    """LS증권 선물옵션 주문 실행기"""

    def __init__(self, session: 'XASession'):
        self.session = session
        self.res_path = "C:/LS_SEC/xingAPI/Res"

    def send_order(self, order: dict) -> dict:
        """
        order = {
            'account': '계좌번호',
            'code': '옵션코드',
            'qty': 수량,
            'price': 가격 (0=시장가),
            'side': 'BUY' or 'SELL',
            'order_type': 'LIMIT' or 'MARKET'
        }
        """
        query = win32com.client.Dispatch("XAQuery.XAQuery")
        query.LoadFromResFile(f"{self.res_path}/CFOAT00100.res")

        # Set input fields
        query.SetFieldData("CFOAT00100InBlock1", "AcntNo", 0, order['account'])
        query.SetFieldData("CFOAT00100InBlock1", "Pwd", 0, order.get('password', ''))
        query.SetFieldData("CFOAT00100InBlock1", "FnoIsuNo", 0, order['code'])
        query.SetFieldData("CFOAT00100InBlock1", "BnsTpCode", 0,
                          '1' if order['side'] == 'SELL' else '2')
        query.SetFieldData("CFOAT00100InBlock1", "FnoOrdprcPtnCode", 0,
                          '00' if order['order_type'] == 'LIMIT' else '03')
        query.SetFieldData("CFOAT00100InBlock1", "OrdPrc", 0, str(order['price']))
        query.SetFieldData("CFOAT00100InBlock1", "OrdQty", 0, str(order['qty']))

        # Request
        query.Request(False)

        # Wait for response
        while not query.IsNext:
            pythoncom.PumpWaitingMessages()

        # Parse result
        return {
            'order_no': query.GetFieldData("CFOAT00100OutBlock1", "OrdNo", 0),
            'result': query.GetFieldData("CFOAT00100OutBlock1", "OrdMktCode", 0)
        }

    def modify_order(self, order: dict) -> dict:
        """CFOAT00200 - 주문 정정"""
        query = win32com.client.Dispatch("XAQuery.XAQuery")
        query.LoadFromResFile(f"{self.res_path}/CFOAT00200.res")

        query.SetFieldData("CFOAT00200InBlock1", "AcntNo", 0, order['account'])
        query.SetFieldData("CFOAT00200InBlock1", "OrgOrdNo", 0, order['org_order_no'])
        query.SetFieldData("CFOAT00200InBlock1", "FnoIsuNo", 0, order['code'])
        query.SetFieldData("CFOAT00200InBlock1", "OrdPrc", 0, str(order['new_price']))
        query.SetFieldData("CFOAT00200InBlock1", "OrdQty", 0, str(order['new_qty']))

        query.Request(False)
        while not query.IsNext:
            pythoncom.PumpWaitingMessages()

        return {
            'order_no': query.GetFieldData("CFOAT00200OutBlock1", "OrdNo", 0),
            'org_order_no': order['org_order_no']
        }

    def cancel_order(self, order: dict) -> dict:
        """CFOAT00300 - 주문 취소"""
        query = win32com.client.Dispatch("XAQuery.XAQuery")
        query.LoadFromResFile(f"{self.res_path}/CFOAT00300.res")

        query.SetFieldData("CFOAT00300InBlock1", "AcntNo", 0, order['account'])
        query.SetFieldData("CFOAT00300InBlock1", "OrgOrdNo", 0, order['org_order_no'])
        query.SetFieldData("CFOAT00300InBlock1", "FnoIsuNo", 0, order['code'])
        query.SetFieldData("CFOAT00300InBlock1", "OrdQty", 0, str(order['qty']))

        query.Request(False)
        while not query.IsNext:
            pythoncom.PumpWaitingMessages()

        return {
            'order_no': query.GetFieldData("CFOAT00300OutBlock1", "OrdNo", 0),
            'cancelled_qty': order['qty']
        }
```

## Production Options Trading System

### Complete System Architecture
```python
class LSOptionsSystem:
    """LS증권 옵션 트레이딩 시스템"""

    def __init__(self, config: dict):
        self.config = config

        # API Components
        self.session = None
        self.real_manager = None
        self.order_executor = None

        # Data Storage
        self.orderbook = {}      # code -> OH0 data
        self.prices = {}         # code -> OC0 data
        self.greeks = {}         # code -> OMG data
        self.futures = {}        # code -> FC0 data

        # Order Management
        self.pending_orders = {}
        self.positions = {}

        # Callbacks
        self.callbacks = {
            'OH0': self.on_orderbook,
            'OC0': self.on_price,
            'OMG': self.on_greeks,
            'FC0': self.on_futures,
            'C01': self.on_fill,
            'H01': self.on_modify_cancel,
            'O01': self.on_order_detail
        }

    def connect(self, server: int = 0):
        """Connect to LS Securities API"""
        self.session = XASession()
        self.session.Login(
            server=server,  # 0=demo, 1=real
            user_id=self.config['user_id'],
            password=self.config['password'],
            cert=self.config.get('cert', '')
        )

        self.real_manager = LSRealManager()
        self.order_executor = LSOrderExecutor(self.session)

    def subscribe_options(self, codes: list):
        """Subscribe to option real-time data"""
        for real_code in ['OH0', 'OC0', 'OMG']:
            self.real_manager.subscribe(
                real_code, codes, self.callbacks[real_code]
            )

    def subscribe_futures(self, codes: list):
        """Subscribe to futures real-time data"""
        self.real_manager.subscribe('FC0', codes, self.callbacks['FC0'])

    def subscribe_orders(self):
        """Subscribe to order notifications"""
        for real_code in ['C01', 'H01', 'O01']:
            self.real_manager.subscribe(real_code, [], self.callbacks[real_code])

    # Event Handlers
    def on_orderbook(self, code: str, data: dict):
        self.orderbook[code] = data
        self.check_strategy_signal(code, 'orderbook')

    def on_price(self, code: str, data: dict):
        self.prices[code] = data
        self.check_strategy_signal(code, 'price')

    def on_greeks(self, code: str, data: dict):
        self.greeks[code] = data
        self.check_strategy_signal(code, 'greeks')

    def on_futures(self, code: str, data: dict):
        self.futures[code] = data

    def on_fill(self, code: str, data: dict):
        order_no = data['order_no']
        if order_no in self.pending_orders:
            self.pending_orders[order_no]['status'] = 'FILLED'
            self.pending_orders[order_no]['fill'] = data
            self.update_position(data)

    def on_modify_cancel(self, code: str, data: dict):
        order_no = data['org_order_no']
        if order_no in self.pending_orders:
            if data['action'] == 'CANCEL':
                self.pending_orders[order_no]['status'] = 'CANCELLED'
            else:
                self.pending_orders[order_no]['status'] = 'MODIFIED'
                self.pending_orders[order_no]['new_order_no'] = data['order_no']

    def on_order_detail(self, code: str, data: dict):
        # Detailed order status update
        pass

    def check_strategy_signal(self, code: str, data_type: str):
        """Check for trading signals"""
        # Implement your strategy logic here
        pass

    def update_position(self, fill: dict):
        """Update position after fill"""
        code = fill['code']
        if code not in self.positions:
            self.positions[code] = {'qty': 0, 'avg_price': 0}

        pos = self.positions[code]
        if fill['side'] == 'BUY':
            total_cost = pos['qty'] * pos['avg_price'] + fill['fill_qty'] * fill['fill_price']
            pos['qty'] += fill['fill_qty']
            pos['avg_price'] = total_cost / pos['qty'] if pos['qty'] > 0 else 0
        else:
            pos['qty'] -= fill['fill_qty']
            if pos['qty'] <= 0:
                pos['qty'] = 0
                pos['avg_price'] = 0
```

## Greeks-Based Trading Strategy

```python
class GreeksBasedStrategy:
    """그릭스 기반 트레이딩 전략"""

    def __init__(self, system: LSOptionsSystem):
        self.system = system
        self.delta_threshold = 0.5
        self.iv_threshold = 0.02  # 2% IV change

    def analyze(self, code: str) -> Optional[dict]:
        """Analyze Greeks for trading signal"""
        if code not in self.system.greeks:
            return None

        greeks = self.system.greeks[code]['greeks']
        iv_data = self.system.greeks[code]['iv']

        # Delta threshold check
        if abs(greeks['delta']) > self.delta_threshold:
            return {
                'signal': 'DELTA_HIGH',
                'action': 'REDUCE' if greeks['delta'] > 0 else 'ADD',
                'reason': f"Delta {greeks['delta']:.4f} exceeds threshold"
            }

        # IV change check
        iv_change = iv_data['current'] - iv_data['prev_close']
        if abs(iv_change) > self.iv_threshold:
            return {
                'signal': 'IV_SPIKE' if iv_change > 0 else 'IV_CRUSH',
                'action': 'SELL' if iv_change > 0 else 'BUY',
                'reason': f"IV changed by {iv_change:.2%}"
            }

        # Theta decay check (for short positions)
        if greeks['theta'] < -0.01:  # Significant theta decay
            return {
                'signal': 'THETA_OPPORTUNITY',
                'action': 'SELL',
                'reason': f"Theta {greeks['theta']:.4f} - premium selling opportunity"
            }

        return None
```

## Error Codes Reference

### Reject Codes (rejcode)
| Code | Description |
|------|-------------|
| 0000 | 정상 |
| 0001 | 계좌번호 오류 |
| 0002 | 비밀번호 오류 |
| 0003 | 주문수량 오류 |
| 0004 | 주문가격 오류 |
| 0010 | 증거금 부족 |
| 0020 | 주문한도 초과 |
| 0030 | 미체결 주문 없음 |
| 0040 | 원주문 상태 오류 |

### Session Status Codes
| Code | Description |
|------|-------------|
| 00 | 정상 |
| 10 | 동시호가 |
| 20 | 장 시작 |
| 30 | 장 마감 |
| 40 | 장외 거래 |
