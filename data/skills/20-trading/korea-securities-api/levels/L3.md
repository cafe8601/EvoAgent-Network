# L3: Advanced Patterns & Production Systems

## Auto-Login System

### Kiwoom Auto-Login via COM Automation
```python
import subprocess
import win32com.client
import time

class KiwoomAutoLogin:
    """ÌÇ§ÏõÄÏ¶ùÍ∂å ÏûêÎèô Î°úÍ∑∏Ïù∏ (ÎπÑÎ∞ÄÎ≤àÌò∏ ÏûÖÎ†• ÏûêÎèôÌôî)"""

    def __init__(self):
        self.shell = win32com.client.Dispatch("WScript.Shell")

    def start_login(self, user_id: str, password: str, cert_password: str):
        # 1. Open Kiwoom login window
        subprocess.Popen(['C:/OpenAPI/Op/openversionup.exe'])
        time.sleep(3)

        # 2. Find login window and input credentials
        self.shell.AppActivate("Open API Login")
        time.sleep(0.5)

        # 3. Input user ID
        self.shell.SendKeys(user_id)
        self.shell.SendKeys("{TAB}")
        time.sleep(0.2)

        # 4. Input password
        self.shell.SendKeys(password)
        self.shell.SendKeys("{TAB}")
        time.sleep(0.2)

        # 5. Input certificate password
        self.shell.SendKeys(cert_password)
        self.shell.SendKeys("{ENTER}")
```

### Version Update Handling
```python
class VersionUpdater:
    """API Î≤ÑÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏûêÎèô Ï≤òÎ¶¨"""

    def check_and_update(self):
        # Check version update window
        hwnd = win32gui.FindWindow(None, "Open API")
        if hwnd:
            # Click update button if exists
            win32gui.PostMessage(hwnd, win32con.WM_COMMAND, 1, 0)
            time.sleep(30)  # Wait for update

            # Restart login process
            self.restart_application()
```

## Multi-Process Architecture

### Process Roles & Queues
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   windowQ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   traderQ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   GUI       ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Strategy  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Trader  ‚îÇ
‚îÇ  (Main)     ‚îÇ              ‚îÇ  Process   ‚îÇ             ‚îÇ  Process ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ≤                           ‚ñ≤                          ‚ñ≤
      ‚îÇ strategyQ                 ‚îÇ receiverQ                ‚îÇ
      ‚ñº                           ‚ñº                          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ  Telegram   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Receiver  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ   Bot       ‚îÇ   teleQ      ‚îÇ  Process   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Queue Setup Pattern
```python
from multiprocessing import Process, Queue

def create_trading_system():
    # Create queues for IPC
    windowQ = Queue()      # GUI ‚Üî Strategy
    receiverQ = Queue()    # Receiver ‚Üí Strategy
    traderQ = Queue()      # Strategy ‚Üí Trader
    strategyQ = Queue()    # Trader ‚Üí Strategy (feedback)
    teleQ = Queue()        # All ‚Üí Telegram
    queryQ = Queue()       # Query requests

    qlist = [windowQ, receiverQ, traderQ, strategyQ, teleQ, queryQ]

    # Start processes
    Process(target=Receiver, args=(qlist,), daemon=True).start()
    Process(target=Strategy, args=(qlist,), daemon=True).start()
    Process(target=Trader, args=(qlist,), daemon=True).start()
    Process(target=TelegramBot, args=(qlist,), daemon=True).start()

    return qlist
```

### Strategy Process Pattern
```python
class Strategy:
    def __init__(self, qlist: list):
        self.windowQ, self.receiverQ, self.traderQ = qlist[:3]
        self.strategyQ, self.teleQ = qlist[3:5]

        # Load configuration
        self.config = ConfigParser()
        self.config.read('config.ini', encoding='utf-8')

    def run(self):
        while True:
            if not self.receiverQ.empty():
                data = self.receiverQ.get()
                self.process_market_data(data)

            if not self.strategyQ.empty():
                feedback = self.strategyQ.get()
                self.process_feedback(feedback)

    def send_order(self, order_info: dict):
        self.traderQ.put(('ORDER', order_info))
        self.teleQ.put(('ORDER_SENT', order_info))
```

## INI Configuration Pattern

### Strategy Configuration
```ini
[STRATEGY]
# Îß§Îß§ ÏÑ§Ï†ï
tradingStart = 090500
tradingEnd = 152000
maxPosition = 5

# ÏÜêÏùµ ÏÑ§Ï†ï (Ìã± Îã®ÏúÑ)
profitTick1 = 3
profitTick2 = 5
profitTick3 = 8
profitTick4 = 12
profitTick5 = 18
profitTick6 = 25

# ÏÜêÏ†à ÏÑ§Ï†ï
stoplossTick = 5
trailingStopTick = 2

# Î∂ÑÌï†Îß§Îß§
splitCount = 3
splitRatio = 0.33,0.33,0.34

[ACCOUNT]
accountNo = 8888888811
password = 0000

[RISK]
maxDailyLoss = -500000
maxPositionLoss = -100000
```

### Configuration Loader
```python
class StrategyConfig:
    def __init__(self, ini_path: str):
        self.config = ConfigParser()
        self.config.read(ini_path, encoding='utf-8')

    @property
    def profit_levels(self) -> list:
        return [
            int(self.config.get('STRATEGY', f'profitTick{i}'))
            for i in range(1, 7)
        ]

    @property
    def trading_hours(self) -> tuple:
        start = self.config.get('STRATEGY', 'tradingStart')
        end = self.config.get('STRATEGY', 'tradingEnd')
        return (start, end)
```

## Error Recovery Patterns

### Connection Recovery
```python
class RobustConnection:
    def __init__(self):
        self.max_retries = 5
        self.retry_delay = 5

    def connect_with_retry(self):
        for attempt in range(self.max_retries):
            try:
                self.kiwoom.comm_connect()
                return True
            except Exception as e:
                self.log_error(f"Connection failed: {e}")
                time.sleep(self.retry_delay * (attempt + 1))
        return False

    def reconnect_on_disconnect(self):
        """OnEventConnectÏóêÏÑú ÏóêÎü¨ ÏΩîÎìú ÏàòÏã† Ïãú Ïû¨Ï†ëÏÜç"""
        if self.error_code == -100:  # Ï†ëÏÜç ÎÅäÍπÄ
            self.teleQ.put(('ALERT', 'Ï†ëÏÜç ÎÅäÍπÄ - Ïû¨Ï†ëÏÜç ÏãúÎèÑ'))
            self.connect_with_retry()
```

### Order State Management
```python
class OrderManager:
    def __init__(self):
        self.pending_orders = {}  # ÎØ∏Ï≤¥Í≤∞ Ï£ºÎ¨∏
        self.filled_orders = {}   # Ï≤¥Í≤∞ ÏôÑÎ£å
        self.order_lock = threading.Lock()

    def on_receive_chejan_data(self, gubun: str, item_cnt: int, fid_list: str):
        if gubun == '0':  # Ï£ºÎ¨∏Ï≤¥Í≤∞
            order_no = self.kiwoom.get_chejan_data(9203)
            status = self.kiwoom.get_chejan_data(913)

            with self.order_lock:
                if status == 'Ï≤¥Í≤∞':
                    self.filled_orders[order_no] = {
                        'price': self.kiwoom.get_chejan_data(910),
                        'qty': self.kiwoom.get_chejan_data(911)
                    }
                    self.pending_orders.pop(order_no, None)

        elif gubun == '1':  # ÏûîÍ≥†Î≥ÄÍ≤Ω
            self.update_position()
```

## Production Monitoring

### Telegram Integration
```python
import telegram
from telegram.ext import Updater, CommandHandler

class TradingBot:
    def __init__(self, token: str, chat_id: str, teleQ: Queue):
        self.bot = telegram.Bot(token=token)
        self.chat_id = chat_id
        self.teleQ = teleQ

    def run(self):
        while True:
            if not self.teleQ.empty():
                msg_type, data = self.teleQ.get()
                self.send_message(self.format_message(msg_type, data))

    def format_message(self, msg_type: str, data: dict) -> str:
        if msg_type == 'ORDER_FILLED':
            return f"‚úÖ Ï≤¥Í≤∞: {data['code']} {data['side']} {data['qty']}Í≥ÑÏïΩ @ {data['price']}"
        elif msg_type == 'POSITION_PNL':
            return f"üí∞ ÏÜêÏùµ: {data['pnl']:+,}Ïõê ({data['pnl_pct']:+.2f}%)"
        elif msg_type == 'ALERT':
            return f"‚ö†Ô∏è ÏïåÎ¶º: {data}"
```

### Performance Logging
```python
import sqlite3

class TradeLogger:
    def __init__(self, db_path: str = 'trades.db'):
        self.conn = sqlite3.connect(db_path)
        self.create_tables()

    def create_tables(self):
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS trades (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                code TEXT,
                side TEXT,
                qty INTEGER,
                price REAL,
                pnl REAL,
                strategy TEXT
            )
        ''')

    def log_trade(self, trade: dict):
        self.conn.execute('''
            INSERT INTO trades (timestamp, code, side, qty, price, pnl, strategy)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            datetime.now().isoformat(),
            trade['code'], trade['side'], trade['qty'],
            trade['price'], trade.get('pnl', 0), trade.get('strategy', '')
        ))
        self.conn.commit()
```

## PyQt5 GUI Integration

### Main Window with Real-time Updates
```python
from PyQt5.QtWidgets import QMainWindow, QTableWidget
from PyQt5.QtCore import QThread, pyqtSignal

class TradingGUI(QMainWindow):
    def __init__(self, qlist: list):
        super().__init__()
        self.windowQ = qlist[0]

        # Start worker thread for queue processing
        self.worker = QueueWorker(self.windowQ)
        self.worker.update_signal.connect(self.update_display)
        self.worker.start()

    def update_display(self, data: dict):
        if data['type'] == 'PRICE':
            self.update_price_table(data)
        elif data['type'] == 'POSITION':
            self.update_position_table(data)

class QueueWorker(QThread):
    update_signal = pyqtSignal(dict)

    def __init__(self, queue: Queue):
        super().__init__()
        self.queue = queue

    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                self.update_signal.emit(data)
            time.sleep(0.01)
```

## Best Practices

### Rate Limiting
```python
import time
from collections import deque

class RateLimiter:
    def __init__(self, max_requests: int, time_window: float):
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = deque()

    def wait_if_needed(self):
        now = time.time()

        # Remove old requests
        while self.requests and self.requests[0] < now - self.time_window:
            self.requests.popleft()

        # Wait if at limit
        if len(self.requests) >= self.max_requests:
            wait_time = self.requests[0] + self.time_window - now
            if wait_time > 0:
                time.sleep(wait_time)

        self.requests.append(time.time())

# Usage
tr_limiter = RateLimiter(max_requests=5, time_window=1.0)  # 5 req/sec
order_limiter = RateLimiter(max_requests=1, time_window=0.2)  # 200ms
```

### Screen Number Management
```python
class ScreenManager:
    """ÌôîÎ©¥Î≤àÌò∏ Í¥ÄÎ¶¨ (ÏµúÎåÄ 200Í∞ú)"""

    def __init__(self):
        self.screens = {}
        self.next_screen = 1000

    def get_screen(self, purpose: str) -> str:
        if purpose not in self.screens:
            self.screens[purpose] = str(self.next_screen)
            self.next_screen += 1
        return self.screens[purpose]

    def release_screen(self, purpose: str):
        if purpose in self.screens:
            # Disconnect real data for this screen
            screen_no = self.screens.pop(purpose)
            self.kiwoom.disconnect_real_data(screen_no)
```
